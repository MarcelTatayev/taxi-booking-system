<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marcel's Taxi - STAP 2: Voertuig Selectie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            color: #333;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
        }

        .booking-container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
            min-height: calc(100vh - 40px);
        }

        .step-header {
            text-align: center;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 25px 20px;
            position: relative;
        }

        .step-progress {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .progress-dot:hover {
            transform: scale(1.2);
        }

        .progress-dot.active {
            background: white;
        }

        .progress-dot.completed {
            background: #28a745;
        }

        .step-title {
            font-size: 22px;
            font-weight: 700;
            color: white;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .back-button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-50%) translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        /* PASSENGER/LUGGAGE CONTROLS */
        .controls-section {
            background: #fff;
            padding: 25px 20px;
        }

        .controls-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .control-item {
            border: 2px solid #2196f3;
            border-radius: 12px;
            padding: 6px 12px;
            background: white;
            box-shadow: 0 2px 8px rgba(33,150,243,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .control-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-icon {
            font-size: 14px;
        }

        .control-label {
            font-size: 12px;
            font-weight: 600;
            color: #2c3e50;
        }

        .control-counter {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: #2c3e50;
            border-radius: 15px;
            padding: 4px 8px;
        }

        .counter-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            background: white;
            color: #2c3e50;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .counter-btn:hover {
            background: #ffc107;
            color: white;
            transform: scale(1.05);
        }

        .counter-value {
            color: white;
            font-size: 12px;
            font-weight: 600;
            min-width: 12px;
            text-align: center;
        }

        /* VEHICLE SECTION */
        .vehicles-section {
            background: #fff;
            padding: 0 20px 25px 20px;
        }

        .vehicle-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
        }

        .vehicle-card {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            min-height: 100px;
            margin-bottom: 10px;
        }

        .vehicle-card:hover:not(.selected) {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.15);
        }


        .vehicle-card.selected {
            background: white;
            color: #000;
            border: 3px solid #28a745;
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(40,167,69,0.3);
        }

        .vehicle-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .vehicle-image {
            width: 120px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            overflow: hidden;
        }

        .vehicle-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }

        .vehicle-details {
            flex: 1;
        }

        .vehicle-name {
            font-size: 20px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 8px;
            text-align: left;
        }

        .vehicle-card.selected .vehicle-name {
            color: #000;
        }

        .vehicle-specs {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .spec-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .vehicle-card.selected .spec-item {
            color: #000;
        }

        .vehicle-card.recommended {
            border: 2px solid #007bff;
            background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);
            box-shadow: 0 4px 20px rgba(0,123,255,0.15);
        }

        .vehicle-card.recommended::before {
            content: "üîπ AANBEVOLEN";
            position: absolute;
            top: -2px;
            right: 15px;
            background: #007bff;
            color: white;
            padding: 4px 12px;
            border-radius: 0 0 8px 8px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        #routeToggle:hover {
            background: linear-gradient(135deg, #bbdefb 0%, #e3f2fd 100%) !important;
            border-color: #1976d2 !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33,150,243,0.3) !important;
        }

        .control-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(33,150,243,0.3);
            border-color: #1976d2;
        }

        .spec-icon {
            font-size: 14px;
            width: 16px;
        }

        .vehicle-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
        }

        .vehicle-price {
            font-size: 32px;
            font-weight: 800;
            color: #2c3e50;
            text-align: right;
        }

        .vehicle-card.selected .vehicle-price {
            color: #000;
        }

        .trip-type {
            background: #2c3e50;
            color: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .vehicle-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }

        .vehicle-card.disabled:hover {
            transform: none;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            border-color: #e9ecef;
        }

        .vehicle-specs {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .vehicle-description {
            font-size: 11px;
            color: #6c757d;
            font-style: italic;
            line-height: 1.3;
        }

        /* ACTION BUTTONS */
        .action-buttons {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-top: 1px solid #dee2e6;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 22px 60px;
            border-radius: 50px;
            font-size: 20px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #667eea 100%);
            transform: translateY(-6px) scale(1.08);
            box-shadow: 0 25px 60px rgba(102, 126, 234, 0.6);
        }

        .btn-primary:disabled {
            background: linear-gradient(135deg, #6c757d 0%, #adb5bd 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.2);
            opacity: 0.6;
        }

        .selected-info {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
            border-radius: 15px;
            padding: 20px;
            margin: 25px 30px;
            font-size: 16px;
            color: #155724;
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.15);
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .status-indicator {
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 8px 20px;
            border-radius: 25px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            display: inline-block;
        }

        .admin-link {
            background: #6c757d;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 12px;
            margin-top: 10px;
            display: inline-block;
        }

        /* DROPDOWN INTERFACE */
        .dropdown-container {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            margin: 0 auto;
            max-width: 500px;
        }

        .dropdown-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }

        .dropdown-row:last-child {
            margin-bottom: 0;
        }

        .dropdown-item {
            display: flex;
            flex-direction: column;
        }

        .dropdown-label {
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .dropdown-wrapper {
            position: relative;
        }

        .dropdown-select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            font-size: 16px;
            font-weight: 500;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
        }

        .dropdown-select:hover {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .dropdown-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        /* LOADING SPINNER */
        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 50px;
            flex-direction: column;
            gap: 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            color: #667eea;
            font-weight: 600;
        }

        /* DROPDOWN LAYOUT */
        .dropdown-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dropdown-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .dropdown-item {
            min-height: 35px;
        }

        /* COUNTER CONTROLS */
        .counter-control {
            background: white;
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.06);
            transition: all 0.3s ease;
        }

        .counter-control:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.12);
        }

        .counter-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .counter-icon {
            font-size: 16px;
        }

        .counter-label {
            font-size: 13px;
            font-weight: 600;
            color: #2c3e50;
        }

        .counter-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #2c3e50;
            border-radius: 15px;
            padding: 3px 10px;
        }

        .counter-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: white;
            color: #2c3e50;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .counter-btn:hover {
            background: #ffc107;
            color: white;
            transform: scale(1.05);
        }

        .counter-value {
            color: white;
            font-size: 12px;
            font-weight: 600;
            min-width: 12px;
            text-align: center;
        }

        /* TRIP TYPE SELECTOR */
        .trip-type-selector {
            margin-bottom: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 10px;
            border: 2px solid #e9ecef;
        }

        .trip-tabs {
            display: flex;
            gap: 5px;
            background: #e9ecef;
            border-radius: 8px;
            padding: 3px;
        }

        .trip-tab {
            flex: 1;
            padding: 12px 20px;
            text-align: center;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            background: transparent;
        }

        .trip-tab:hover {
            background: rgba(255,255,255,0.8);
            color: #2c3e50;
        }

        .trip-tab.active {
            background: white;
            color: #2c3e50;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        /* SURCHARGE SECTION */
        .surcharge-section {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
        }

        /* BABY SEAT DROPDOWN */
        .child-seat-multi-dropdown {
            display: none !important;
            margin-top: 10px;
            margin-left: 35px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .child-seat-multi-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .child-seat-multi-option:hover {
            background: #e3f2fd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .child-seat-multi-option input[type="checkbox"] {
            margin-right: 10px;
        }

        .child-seat-multi-option label {
            flex: 1;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
        }

        .child-seat-multi-price {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
        }

        .surcharge-header {
            display: none;
        }

        .surcharge-title {
            color: #2c3e50;
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .surcharge-subtitle {
            color: #6c757d;
            font-size: 14px;
            margin: 0;
            font-weight: 400;
        }

        .surcharge-items-container {
            margin-bottom: 15px;
        }

        .surcharge-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .surcharge-item:hover {
            background: white;
            border-color: #007bff;
            box-shadow: 0 2px 8px rgba(0,123,255,0.15);
        }

        .surcharge-item-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .surcharge-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            border: 2px solid #667eea;
            border-radius: 4px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .surcharge-item label {
            font-weight: 600;
            color: #2c3e50;
            cursor: pointer;
            font-size: 16px;
        }

        .surcharge-item-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .surcharge-price {
            font-weight: 700;
            color: #667eea;
            font-size: 18px;
            min-width: 80px;
            text-align: right;
        }

        .quantity-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #f8f9fa;
            border-radius: 25px;
            padding: 5px;
        }

        .quantity-controls button {
            width: 35px;
            height: 35px;
            border: none;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            color: #667eea;
        }

        .quantity-controls button:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .quantity-controls input {
            width: 45px;
            text-align: center;
            border: none;
            background: transparent;
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .surcharge-total {
            display: none;
        }

        .surcharge-total-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .surcharge-total-label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 18px;
        }

        .surcharge-total-amount {
            font-weight: 700;
            color: #007bff;
            font-size: 20px;
        }

        .automatic-surcharge {
            position: relative;
        }
        
        .automatic-surcharge::before {
            content: "AUTO";
            position: absolute;
            top: -8px;
            right: -8px;
            background: #2196f3;
            color: white;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 10px;
            z-index: 10;
        }
        
        /* Notification animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
    </style>
    <!-- Google Maps API (dynamically loaded with admin panel key) -->
    <script src="maps-config.js"></script>
    <script>
        // Global variable for maps functionality
        let mapInitialized = false;
        let routeMap = null;
        let directionsService = null;
        let directionsRenderer = null;
    </script>
</head>
<body>
    <div class="booking-container">
        <button class="back-button" onclick="goBack()">‚Üê Terug naar STAP 1</button>
        
        <div class="step-header">
            <h1 class="step-title">STAP 2: Voertuig Selectie</h1>
            <div class="step-progress">
                <div class="progress-dot completed" onclick="goToStep(1)" title="Ga naar STAP 1"></div>
                <div class="progress-dot active"></div>
                <div class="progress-dot" onclick="goToStep(3)" title="Ga naar STAP 3 (eerst voertuig selecteren)"></div>
            </div>
        </div>


        <!-- PASSENGER SELECTION -->
        <div class="controls-section">
            <div class="controls-grid">
                <div class="control-item">
                    <div class="control-header">
                        <span class="control-icon">üë•</span>
                        <span class="control-label">Passagiers</span>
                    </div>
                    <div class="control-counter">
                        <button class="counter-btn" onclick="changeCount('passengers', -1)">-</button>
                        <span class="counter-value" id="passengersCount">1</span>
                        <button class="counter-btn" onclick="changeCount('passengers', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-item">
                    <div class="control-header">
                        <span class="control-icon">üß≥</span>
                        <span class="control-label">Koffers</span>
                    </div>
                    <div class="control-counter">
                        <button class="counter-btn" onclick="changeCount('koffers', -1)">-</button>
                        <span class="counter-value" id="koffersCount">0</span>
                        <button class="counter-btn" onclick="changeCount('koffers', 1)">+</button>
                    </div>
                </div>
                
                <div class="control-item">
                    <div class="control-header">
                        <span class="control-icon">üíº</span>
                        <span class="control-label">Handbagage</span>
                    </div>
                    <div class="control-counter">
                        <button class="counter-btn" onclick="changeCount('handbagage', -1)">-</button>
                        <span class="counter-value" id="handbagageCount">0</span>
                        <button class="counter-btn" onclick="changeCount('handbagage', 1)">+</button>
                    </div>
                </div>
            </div>
            <div id="passengerRecommendation" style="text-align: center; font-size: 14px; color: #666; margin-top: 15px;"></div>
        </div>

        <!-- ROUTE INFORMATION -->
        <div id="routeInfo" style="display: none;"></div>

        <!-- VEHICLES -->
        <div class="vehicles-section">
            <!-- Trip Type Selector HIDDEN - Not needed for user interface -->
            <div id="tripTypeSelector" class="trip-type-selector" style="display: none !important;">
                <div class="trip-tabs">
                    <div class="trip-tab active" id="outboundTab" onclick="switchTripType('outbound')">
                        <span>üìç Heen reis</span>
                    </div>
                    <div class="trip-tab" id="returnTab" onclick="switchTripType('return')">
                        <span>üîÑ Terug reis</span>
                    </div>
                </div>
            </div>
            
            <!-- Vehicle Grid for Outbound Trip -->
            <div class="vehicle-grid" id="vehicleGridOutbound">
                <div class="loading">
                    <h3>üîÑ Laden...</h3>
                    <p>Voertuigen laden van Types of Vehicles en Distance & Time Pricing</p>
                </div>
            </div>
            
            <!-- Vehicle Grid for Return Trip -->
            <div class="vehicle-grid" id="vehicleGridReturn" style="display: none;">
                <div class="loading">
                    <h3>üîÑ Laden...</h3>
                    <p>Voertuigen laden voor terug reis</p>
                </div>
            </div>
            
        </div>

        <!-- ITEM SURCHARGE SECTION -->
        <div id="surchargeSection" class="surcharge-section" style="display: none;">
            <div class="surcharge-header">
                <h3 class="surcharge-title">Extra Services</h3>
                <p class="surcharge-subtitle">Selecteer optionele services voor uw reis</p>
            </div>
            
            <!-- Fixed Items -->
            <div id="fixedSurchargeItems" class="surcharge-items-container"></div>
            
            <!-- Additional Items -->
            <div id="additionalSurchargeItems" class="surcharge-items-container"></div>
            
            <!-- Total surcharge display -->
            <div id="surchargeTotal" class="surcharge-total">
                <div class="surcharge-total-content">
                    <span class="surcharge-total-label">Extra Services Totaal:</span>
                    <span id="surchargeTotalAmount" class="surcharge-total-amount">‚Ç¨0.00</span>
                </div>
            </div>
        </div>

        <!-- ROUTE MAP TOGGLE -->
        <div class="vehicles-section" style="border-top: 1px solid #e9ecef; padding-top: 20px;">
            <div id="routeToggle" onclick="toggleRouteMap()" style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 12px; background: white; border-radius: 12px; border: 3px solid #2196f3; margin-bottom: 15px; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                <span id="routeIcon" style="display: flex; align-items: center;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M21 10C21 17 12 23 12 23S3 17 3 10C3 5.02944 7.02944 1 12 1C16.9706 1 21 5.02944 21 10Z" stroke="#6c757d" stroke-width="2"/>
                        <circle cx="12" cy="10" r="3" stroke="#6c757d" stroke-width="2"/>
                    </svg>
                </span>
                <span id="routeToggleText" style="font-weight: 600; color: #2c3e50;">Toon kaart</span>
            </div>
            
            <div id="routeMapSection" style="display: none;">
                <div id="mapContainer" style="width: 100%; height: 300px; border-radius: 12px; overflow: hidden; border: 2px solid #e9ecef; background: #f8f9fa; display: flex; align-items: center; justify-content: center; color: #6c757d;">
                    <div id="mapLoading">
                        <div style="text-align: center;">
                            <div style="font-size: 18px; margin-bottom: 10px;">üó∫Ô∏è Route wordt geladen...</div>
                            <div style="font-size: 14px;">Van: <span id="routeFrom">-</span></div>
                            <div style="font-size: 14px;">Naar: <span id="routeTo">-</span></div>
                        </div>
                    </div>
                    <div id="map" style="width: 100%; height: 100%; display: none;"></div>
                </div>
                <div id="routeInfo" style="display: flex; justify-content: space-between; margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px;">
                    <div><strong>Afstand:</strong> <span id="routeDistance">Berekenen...</span></div>
                    <div><strong>Tijd:</strong> <span id="routeDuration">Berekenen...</span></div>
                    <div><strong>Route type:</strong> <span id="routeType">Snelste route</span></div>
                </div>
            </div>
        </div>

        <!-- SELECTED INFO -->
        <div id="selectedInfo" class="selected-info" style="display: block;">
            <strong>‚úÖ Geselecteerd:</strong> <span id="selectedVehicleName"></span><br>
            <strong>Prijs:</strong> <span id="selectedMinPrice"></span>
        </div>


        <!-- ACTION BUTTONS -->
        <div class="action-buttons">
            <button class="btn-primary" id="continueBtn" onclick="continueToStep3()" disabled>
                Volgende: STAP 3 - Klantgegevens
            </button>
        </div>
    </div>

    <script>
        let selectedVehicleOutbound = null;
        let selectedVehicleReturn = null;
        let vehicles = [];
        let pricingData = {};
        let currentTripType = 'outbound';
        let hasReturnTrip = false;
        let calculatedDistance = 0; // in kilometers
        let distanceCalculated = false;
        let routeDetails = null;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ STAP 2 - Page initializing...');
            
            // Check last-minute booking restrictions first
            checkLastMinuteBooking();
            
            // Load Google Maps API first
            loadGoogleMapsAPI()
                .then(() => {
                    console.log('‚úÖ Google Maps API loaded from admin settings');
                    
                    // Wait a moment for all Google Maps objects to be available
                    setTimeout(() => {
                        // Test if Google Maps is actually working
                        if (typeof google !== 'undefined' && google.maps && google.maps.Geocoder) {
                            console.log('‚úÖ Google Maps object available');
                            console.log('üìç Google Maps version:', google.maps.version);
                            
                            // Test Google Maps functionality with a simple geocode
                            try {
                                const testGeocoder = new google.maps.Geocoder();
                                testGeocoder.geocode({ address: 'Brussels, Belgium' }, function(results, status) {
                                    if (status === google.maps.GeocoderStatus.OK) {
                                        console.log('‚úÖ Google Maps Geocoder test successful');
                                    } else {
                                        console.error('‚ùå Google Maps Geocoder test failed:', status);
                                    }
                                });
                            } catch (error) {
                                console.error('‚ùå Google Maps Geocoder creation failed:', error);
                            }
                        } else {
                            console.error('‚ùå Google Maps object not available after loading');
                            console.log('üìç Available google object:', typeof google);
                            if (typeof google !== 'undefined') {
                                console.log('üìç Available google.maps:', typeof google.maps);
                                if (google.maps) {
                                    console.log('üìç Available Geocoder:', typeof google.maps.Geocoder);
                                }
                            }
                        }
                    }, 500); // Wait 500ms for full initialization
                })
                .catch((error) => {
                    console.error('‚ùå Google Maps API failed to load:', error);
                    console.log('üìç Error details:', error);
                    
                    // Check what's in localStorage
                    const googleSettings = JSON.parse(localStorage.getItem('googleSettings') || '{}');
                    console.log('üìç Google settings from localStorage:', googleSettings);
                    
                    console.log('üìç Using fallback route calculations');
                });
            
            // Initialize counters from localStorage or defaults
            initializeCounters();
            
            // Initial vehicle filtering after counters are set
            console.log('üîÑ Running initial vehicle filtering...');
            
            checkReturnTrip();
            loadSystemData();
            
            // Load location surcharges
            loadLocationSurcharges();
            
            // Load and display route info from STEP 1
            loadRouteInfoFromStep1();
            calculateRouteDistance();
            // Do NOT override user's counter selection
            // selectPassengers(1); // Disabled - initializeCounters() already sets correct values
            // Load route information - DISABLED (route info hidden)
            // loadRouteInfo();
            // Load surcharge items immediately
            console.log('üìÑ Loading surcharge items...');
            loadSurchargeItems();
            
            // Start pricing update checker
            console.log('üí∞ Starting pricing update checker...');
            setInterval(checkForPricingUpdates, 2000); // Check every 2 seconds
            
            
            
            // Set up automatic checking for admin updates
            setInterval(checkForAdminUpdates, 5000); // Check every 5 seconds
        });

        function checkForAdminUpdates() {
            // Check for surcharge updates
            checkForSurchargeUpdates();
            
            // Check for vehicle capacity updates
            checkForVehicleUpdates();
        }

        function checkForVehicleUpdates() {
            const currentTimestamp = localStorage.getItem('vehicleUpdateTimestamp');
            const lastCheckedTimestamp = window.lastVehicleCheck || 0;
            
            if (currentTimestamp && currentTimestamp > lastCheckedTimestamp) {
                console.log('üîÑ Vehicle capacity updates detected, refreshing...');
                window.lastVehicleCheck = currentTimestamp;
                
                // Reload vehicle data
                loadSystemData();
                
                // Re-render vehicles with new capacity data
                if (vehicles && vehicles.length > 0) {
                    renderVehicles();
                    filterAndRenderVehicles();
                }
                
                console.log('‚úÖ Vehicle capacity data refreshed');
            }
        }


        async function calculateRouteDistance() {
            
            const fromLocation = localStorage.getItem('fromLocation');
            const toLocation = localStorage.getItem('toLocation');
            const extraStopCount = parseInt(localStorage.getItem('extraStopCount') || '0');
            
            if (!fromLocation || !toLocation) {
                console.warn('‚ö†Ô∏è Missing from/to locations for distance calculation');
                return;
            }
            
            // Collect all extra stops - FIXED: Use extraStops array from STAP 1
            const extraStops = JSON.parse(localStorage.getItem('extraStops') || '[]');
            console.log(`üìç Found ${extraStops.length} extra stops from STAP 1:`, extraStops);
            
            console.log(`üìç Route: ${fromLocation} ${extraStops.length > 0 ? '‚Üí ' + extraStops.join(' ‚Üí ') + ' ' : ''}‚Üí ${toLocation}`);
            
            // Show loading indicator
            showDistanceLoading();
            
            try {
                if (typeof google !== 'undefined' && google.maps) {
                    
                    // Try to get saved coordinates from Step 1 first
                    const fromLat = localStorage.getItem('fromLat');
                    const fromLng = localStorage.getItem('fromLng');
                    const toLat = localStorage.getItem('toLat');
                    const toLng = localStorage.getItem('toLng');
                    
                    let fromCoords, toCoords;
                    
                    if (fromLat && fromLng && toLat && toLng) {
                        // Use saved coordinates from Step 1
                        fromCoords = { lat: parseFloat(fromLat), lng: parseFloat(fromLng) };
                        toCoords = { lat: parseFloat(toLat), lng: parseFloat(toLng) };
                        console.log('üìç Using saved coordinates from Step 1');
                    } else {
                        // Fallback to geocoding
                        console.log('üìç Geocoding addresses...');
                        const geocoder = new google.maps.Geocoder();
                        fromCoords = await geocodeAddress(geocoder, fromLocation);
                        toCoords = await geocodeAddress(geocoder, toLocation);
                    }
                    
                    if (fromCoords && toCoords) {
                        // Try Directions Service for accurate driving distance with waypoints
                        try {
                            const directionsService = new google.maps.DirectionsService();
                            
                            // Build waypoints from extra stops
                            const waypoints = [];
                            if (extraStops.length > 0) {
                                for (const stop of extraStops) {
                                    waypoints.push({
                                        location: stop,
                                        stopover: true
                                    });
                                }
                            }
                            
                            const result = await new Promise((resolve, reject) => {
                                directionsService.route({
                                    origin: fromLocation,
                                    destination: toLocation,
                                    waypoints: waypoints,
                                    travelMode: google.maps.TravelMode.DRIVING,
                                    unitSystem: google.maps.UnitSystem.METRIC,
                                    optimizeWaypoints: false // Keep order of stops
                                }, (response, status) => {
                                    if (status === google.maps.DirectionsStatus.OK) {
                                        resolve(response);
                                    } else {
                                        reject(new Error(`Directions API error: ${status}`));
                                    }
                                });
                            });
                            
                            // Extract total distance and duration from all route legs
                            const route = result.routes[0];
                            let totalDistance = 0;
                            let totalDuration = 0;
                            
                            // Sum all legs (A‚ÜíStop1, Stop1‚ÜíStop2, Stop2‚ÜíB)
                            route.legs.forEach(leg => {
                                totalDistance += leg.distance.value;
                                totalDuration += leg.duration.value;
                            });
                            
                            calculatedDistance = Math.round((totalDistance / 1000) * 100) / 100;
                            distanceCalculated = true;
                            
                            // Format duration
                            const hours = Math.floor(totalDuration / 3600);
                            const minutes = Math.floor((totalDuration % 3600) / 60);
                            const durationText = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
                            
                            routeDetails = {
                                distance: `${calculatedDistance} km`,
                                duration: durationText,
                                distanceKm: calculatedDistance,
                                stops: extraStops.length,
                                route: `${fromLocation}${extraStops.length > 0 ? ' ‚Üí ' + extraStops.join(' ‚Üí ') + ' ' : ''}‚Üí ${toLocation}`
                            };
                            
                            console.log(`‚úÖ Route calculated via Directions API with ${extraStops.length} stops: ${calculatedDistance} km (${durationText})`);
                            
                        } catch (directionsError) {
                            console.warn('‚ö†Ô∏è Directions API failed, using straight-line distance with stops:', directionsError);
                            
                            // Fallback: calculate straight-line distance including all stops
                            let totalStraightDistance = 0;
                            
                            // Get coordinates for all stops
                            const allStopCoords = [fromCoords];
                            
                            // Add extra stop coordinates (if we have them)
                            for (let i = 1; i <= extraStops.length; i++) {
                                const stopLat = localStorage.getItem(`extraStop${i}Lat`);
                                const stopLng = localStorage.getItem(`extraStop${i}Lng`);
                                if (stopLat && stopLng) {
                                    allStopCoords.push({ lat: parseFloat(stopLat), lng: parseFloat(stopLng) });
                                }
                            }
                            
                            allStopCoords.push(toCoords);
                            
                            // Calculate distance between consecutive points
                            for (let i = 0; i < allStopCoords.length - 1; i++) {
                                const segmentDistance = google.maps.geometry.spherical.computeDistanceBetween(
                                    new google.maps.LatLng(allStopCoords[i].lat, allStopCoords[i].lng),
                                    new google.maps.LatLng(allStopCoords[i + 1].lat, allStopCoords[i + 1].lng)
                                );
                                totalStraightDistance += segmentDistance;
                            }
                            
                            // REMOVED hardcoded 1.3 multiplier - respect admin pricing only
                            calculatedDistance = Math.round((totalStraightDistance / 1000) * 100) / 100;
                            distanceCalculated = true;
                            
                            // Estimate duration (assuming 50 km/h average speed)
                            const estimatedDuration = Math.round((calculatedDistance / 50) * 60); // minutes
                            
                            routeDetails = {
                                distance: `${calculatedDistance} km`,
                                duration: `~${estimatedDuration} min`,
                                distanceKm: calculatedDistance,
                                stops: extraStops.length,
                                route: `${fromLocation}${extraStops.length > 0 ? ' ‚Üí ' + extraStops.join(' ‚Üí ') + ' ' : ''}‚Üí ${toLocation}`
                            };
                            
                            console.log(`‚úÖ Route estimated via straight-line with ${extraStops.length} stops: ${calculatedDistance} km (~${estimatedDuration} min)`);
                        }
                        
                        // Update route info display
                        updateRouteDisplay();
                        
                        // Recalculate vehicle prices with distance
                        recalculateVehiclePrices();
                        
                    } else {
                        throw new Error('Could not get coordinates for addresses');
                    }
                    
                } else {
                    throw new Error('Google Maps not loaded');
                }
                
            } catch (error) {
                console.error('‚ùå Distance calculation failed:', error);
                // Fallback to minimum prices
                calculatedDistance = 0;
                distanceCalculated = false;
                hideDistanceLoading();
                showDistanceError();
            }
        }

        async function geocodeAddress(geocoder, address) {
            return new Promise((resolve, reject) => {
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const location = results[0].geometry.location;
                        resolve({
                            lat: location.lat(),
                            lng: location.lng()
                        });
                    } else {
                        reject(new Error(`Geocoding failed for ${address}: ${status}`));
                    }
                });
            });
        }

        function showDistanceLoading() {
            // Route information hidden as requested
            const routeInfo = document.getElementById('routeInfo');
            if (routeInfo) {
                routeInfo.style.display = 'none';
            }
        }

        function hideDistanceLoading() {
            // Route information hidden as requested
            const routeInfo = document.getElementById('routeInfo');
            if (routeInfo) {
                routeInfo.style.display = 'none';
            }
        }

        function showDistanceError() {
            // Route information hidden as requested
            const routeInfo = document.getElementById('routeInfo');
            if (routeInfo) {
                routeInfo.style.display = 'none';
            }
        }

        function updateRouteDisplay() {
            // Route information hidden as requested
            const routeInfo = document.getElementById('routeInfo');
            if (routeInfo) {
                routeInfo.style.display = 'none';
                return;
            }
            if (routeInfo && routeDetails) {
                let stopsInfo = '';
                if (routeDetails.stops > 0) {
                    stopsInfo = `<div style="color: #666; font-size: 12px; margin-top: 8px;">
                        Route: ${routeDetails.route}
                    </div>`;
                }
                
                // Route information hidden as requested
                routeInfo.style.display = 'none';
            }
        }

        function recalculateVehiclePrices() {
            console.log('üí∞ Recalculating vehicle prices with distance...');
            
            // Update selected vehicle pricing data if a vehicle is already selected
            if (selectedVehicleOutbound) {
                const vehicleId = selectedVehicleOutbound.vehicle.id || getVehicleIdFromName(selectedVehicleOutbound.vehicle.name);
                const basePricing = pricingData[vehicleId] || { minimumPrice: 50.00, pricePerKm: 2.00 };
                basePricing.vehicleId = vehicleId; // Ensure vehicleId is included
                const newPricing = calculateDistanceBasedPricing(basePricing);
                
                // Update the selected vehicle's pricing data
                selectedVehicleOutbound.pricing = newPricing;
                console.log(`üí∞ Updated selected vehicle (${selectedVehicleOutbound.vehicle.name}) pricing:`, newPricing);
                
                // Update the total price immediately
                updateTotalPrice();
            }
            
            if (selectedVehicleReturn) {
                const vehicleId = selectedVehicleReturn.vehicle.id || getVehicleIdFromName(selectedVehicleReturn.vehicle.name);
                const basePricing = pricingData[vehicleId] || { minimumPrice: 50.00, pricePerKm: 2.00 };
                basePricing.vehicleId = vehicleId; // Ensure vehicleId is included
                const newPricing = calculateDistanceBasedPricing(basePricing);
                
                // Update the selected vehicle's pricing data
                selectedVehicleReturn.pricing = newPricing;
                console.log(`üí∞ Updated selected return vehicle (${selectedVehicleReturn.vehicle.name}) pricing:`, newPricing);
            }
            
            // Trigger vehicle grid re-render with new distance-based prices
            renderVehicles();
        }

        function getVehicleIdFromPricing(basePricing) {
            // Return vehicle ID if available, otherwise fallback to saloon
            return basePricing.vehicleId || 'saloon';
        }
        
        function getVehicleIdFromName(vehicleName) {
            // Convert vehicle name to ID for pricing lookup
            const nameToId = {
                'Saloon': 'saloon',
                'Estate': 'estate', 
                'Minivan': 'minivan',
                'Minivan Long': 'minivan-long'
            };
            return nameToId[vehicleName] || vehicleName.toLowerCase().replace(/\s+/g, '-');
        }

        // FORCE Partner markup everywhere
        function applyPartnerMarkup(price) {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.has('partner')) {
                const markup = parseInt(urlParams.get('markup')) || 5;
                console.log(`üöÄ FORCE MARKUP: ‚Ç¨${price} -> ‚Ç¨${price + markup}`);
                return price + markup;
            }
            
            return price;
        }
        
        // Override ALL price functions
        const originalPrice = window.calculateVehiclePrice || function() { return 50; };
        window.calculateVehiclePrice = function(vehicle) {
            const basePrice = originalPrice.call(this, vehicle) || 50;
            return applyPartnerMarkup(basePrice);
        };


        function calculateDistanceBasedPricing(basePricing) {
            if (!distanceCalculated || calculatedDistance <= 0) {
                // If distance is not calculated or invalid, use minimum price only
                const minPrice = applyPartnerMarkup(basePricing.minimumPrice);
                return {
                    minimumPrice: minPrice,
                    pricePerKm: basePricing.pricePerKm,
                    isDistanceBased: false,
                    originalMinimum: basePricing.minimumPrice
                };
            }
            
            // üÜï Load kilometer ranges from admin pricing
            const vehicleId = basePricing.vehicleId || getVehicleIdFromPricing(basePricing);
            const vehiclePricing = JSON.parse(localStorage.getItem('vehiclePricing') || '{}');
            const distanceRanges = vehiclePricing[vehicleId]?.distanceRanges;
            
            let distancePrice = 0;
            let calculationDetails = '';
            
            if (distanceRanges && distanceRanges.length > 0) {
                // üéØ USE KILOMETER RANGES FROM ADMIN
                let remainingDistance = calculatedDistance;
                let totalPrice = 0;
                let priceBreakdown = [];
                
                for (let i = 0; i < distanceRanges.length; i++) {
                    const range = distanceRanges[i];
                    const rangeStart = range.min;
                    const rangeEnd = range.max;
                    const rangePrice = range.price;
                    
                    if (remainingDistance <= 0) break;
                    
                    // Calculate how many km fall in this range
                    const effectiveStart = Math.max(rangeStart, calculatedDistance - remainingDistance);
                    const effectiveEnd = Math.min(rangeEnd, calculatedDistance);
                    const kmInRange = Math.max(0, effectiveEnd - effectiveStart);
                    
                    if (kmInRange > 0) {
                        const rangeTotal = kmInRange * rangePrice;
                        totalPrice += rangeTotal;
                        priceBreakdown.push(`${kmInRange}km √ó ‚Ç¨${rangePrice.toFixed(2)} = ‚Ç¨${rangeTotal.toFixed(2)}`);
                        
                        console.log(`üìä Range ${i+1}: ${rangeStart}-${rangeEnd}km, ${kmInRange}km @ ‚Ç¨${rangePrice.toFixed(2)} = ‚Ç¨${rangeTotal.toFixed(2)}`);
                    }
                }
                
                distancePrice = totalPrice;
                calculationDetails = priceBreakdown.join(' + ') + ` = ‚Ç¨${distancePrice.toFixed(2)}`;
                
                console.log(`üìä üéØ KILOMETER RANGES USED: ${calculationDetails}`);
            } else {
                // üìä FALLBACK: Use standard pricing if no ranges configured
                distancePrice = calculatedDistance * basePricing.pricePerKm;
                calculationDetails = `${calculatedDistance}km √ó ‚Ç¨${basePricing.pricePerKm.toFixed(2)} = ‚Ç¨${distancePrice.toFixed(2)}`;
                
                console.log(`üìä Standard pricing (no ranges): ${calculationDetails}`);
            }
            
            // üéØ KILOMETER RANGES + MINIMUM CHECK: Use the higher of kilometer calculation OR minimum price
            const adminMinimum = basePricing.minimumPrice || basePricing.minimum || 50.00;
            let calculatedPrice;
            
            if (distanceRanges && distanceRanges.length > 0) {
                // Use kilometer ranges calculation BUT respect minimum price
                calculatedPrice = Math.max(distancePrice, adminMinimum);
                
                if (distancePrice >= adminMinimum) {
                    console.log(`üéØ KILOMETER RANGES: Distance price ‚Ç¨${distancePrice.toFixed(2)} > minimum ‚Ç¨${adminMinimum} ‚Üí using distance price`);
                } else {
                    console.log(`üéØ KILOMETER RANGES: Distance price ‚Ç¨${distancePrice.toFixed(2)} < minimum ‚Ç¨${adminMinimum} ‚Üí using minimum price`);
                }
            } else {
                // Standard: use higher of per-km calculation or minimum price
                calculatedPrice = Math.max(distancePrice, adminMinimum);
                console.log(`üìä STANDARD: Using max of distance (‚Ç¨${distancePrice.toFixed(2)}) or admin minimum (‚Ç¨${adminMinimum}): ‚Ç¨${calculatedPrice.toFixed(2)}`);
            }
            
            // Apply partner markup BEFORE rounding
            const priceWithMarkup = applyPartnerMarkup(calculatedPrice);
            
            // Round up to next whole euro
            const finalPrice = Math.ceil(priceWithMarkup);
            console.log(`üí∏ EXACT PRICE before rounding: ‚Ç¨${priceWithMarkup.toFixed(2)} ‚Üí rounded to ‚Ç¨${finalPrice}`);
            
            // Determine if minimum or distance price was used (before rounding)
            const usingMinimum = (distanceRanges && distanceRanges.length > 0) ? 
                (calculatedPrice === adminMinimum) : (calculatedPrice === adminMinimum);
            
            const tripText = hasReturnTrip ? ' (single direction - will be doubled in total)' : '';
            let minimumText;
            if (distanceRanges && distanceRanges.length > 0) {
                minimumText = 'üéØ Using kilometer ranges (minimum ignored)';
            } else {
                minimumText = usingMinimum ? `< admin min ‚Ç¨${adminMinimum} ‚Üí using minimum` : `> admin min ‚Ç¨${adminMinimum} ‚Üí using distance`;
            }
            console.log(`üìä Final: ${calculationDetails} ${minimumText} ‚Üí rounded up to ‚Ç¨${finalPrice}${tripText}`);
            
            return {
                minimumPrice: finalPrice,
                pricePerKm: basePricing.pricePerKm,
                isDistanceBased: true,
                originalMinimum: basePricing.minimumPrice,
                distanceKm: calculatedDistance,
                effectiveDistanceKm: calculatedDistance,
                distanceCharge: distancePrice,
                usingMinimum: usingMinimum,
                hasReturnTrip: hasReturnTrip,
                usedDistanceBasedRates: false,
                threshold: 0,
                longDistanceRate: 0
            };
        }

        function checkReturnTrip() {
            const returnActive = localStorage.getItem('returnActive');
            hasReturnTrip = returnActive === 'true';
            
            // Trip selector tabs hidden - not needed for user interface
            // Both outbound and return use same vehicle
            document.getElementById('tripTypeSelector').style.display = 'none';
            
            // Update individual surcharge price displays when return trip status changes
            updateIndividualSurchargePrices();
        }

        function updateIndividualSurchargePrices() {
            // Items that should be doubled for return trips
            const doubleForReturnItems = [
                'child-seat', 'booster-seat', 'infant-seat',
                'dog', 'golf-material', 'ski-material', 'extra-waiting-time'
            ];
            
            // Update all .surcharge-price elements
            document.querySelectorAll('.surcharge-price').forEach(priceElement => {
                const itemContainer = priceElement.closest('.surcharge-item, .surcharge-item-inline');
                if (!itemContainer) return;
                
                const itemId = itemContainer.querySelector('input[type="checkbox"]')?.getAttribute('onchange')?.match(/toggleSurcharge\('([^']+)'/)?.[1];
                if (!itemId) return;
                
                const originalPrice = parseFloat(priceElement.getAttribute('data-original-price') || priceElement.textContent.replace('‚Ç¨', ''));
                if (!priceElement.hasAttribute('data-original-price')) {
                    priceElement.setAttribute('data-original-price', originalPrice);
                }
                
                if (hasReturnTrip && doubleForReturnItems.includes(itemId)) {
                    const doubledPrice = originalPrice * 2;
                    priceElement.innerHTML = `‚Ç¨${doubledPrice.toFixed(2)} <small style="color: #666;">(heen & terug)</small>`;
                } else {
                    priceElement.textContent = `‚Ç¨${originalPrice.toFixed(2)}`;
                }
            });
            
            // Update child seat dropdown option prices
            document.querySelectorAll('.child-seat-multi-price').forEach(priceElement => {
                const optionContainer = priceElement.closest('.child-seat-multi-option');
                if (!optionContainer) return;
                
                const checkboxInput = optionContainer.querySelector('input[type="checkbox"]');
                const itemId = checkboxInput?.id?.split('_')[0];
                
                const originalPrice = parseFloat(priceElement.getAttribute('data-original-price') || priceElement.textContent.replace('‚Ç¨', ''));
                if (!priceElement.hasAttribute('data-original-price')) {
                    priceElement.setAttribute('data-original-price', originalPrice);
                }
                
                if (hasReturnTrip && doubleForReturnItems.includes(itemId)) {
                    const doubledPrice = originalPrice * 2;
                    priceElement.innerHTML = `‚Ç¨${doubledPrice.toFixed(2)} <small style="color: #666;">(heen & terug)</small>`;
                } else {
                    priceElement.textContent = `‚Ç¨${originalPrice.toFixed(2)}`;
                }
            });
            
            // Update additional item prices (.baby-seat-price)
            document.querySelectorAll('.baby-seat-price').forEach(priceElement => {
                const itemContainer = priceElement.closest('.surcharge-item, .surcharge-item-inline');
                if (!itemContainer) return;
                
                const selectElement = itemContainer.querySelector('select');
                const itemId = selectElement?.getAttribute('onchange')?.match(/selectAdditionalVariant\('([^']+)'/)?.[1];
                
                const originalPrice = parseFloat(priceElement.getAttribute('data-original-price') || priceElement.textContent.replace('‚Ç¨', ''));
                if (!priceElement.hasAttribute('data-original-price')) {
                    priceElement.setAttribute('data-original-price', originalPrice);
                }
                
                if (hasReturnTrip && doubleForReturnItems.includes(itemId)) {
                    const doubledPrice = originalPrice * 2;
                    priceElement.innerHTML = `‚Ç¨${doubledPrice.toFixed(2)} <small style="color: #666;">(heen & terug)</small>`;
                } else {
                    priceElement.textContent = `‚Ç¨${originalPrice.toFixed(2)}`;
                }
            });
            
            console.log(`üîÑ Updated individual surcharge prices for return trip: ${hasReturnTrip}`);
        }

        function switchTripType(tripType) {
            currentTripType = tripType;
            
            // Update tab active state
            document.querySelectorAll('.trip-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            if (tripType === 'outbound') {
                document.getElementById('outboundTab').classList.add('active');
                document.getElementById('vehicleGridOutbound').style.display = 'block';
                document.getElementById('vehicleGridReturn').style.display = 'none';
            } else {
                document.getElementById('returnTab').classList.add('active');
                document.getElementById('vehicleGridOutbound').style.display = 'none';
                document.getElementById('vehicleGridReturn').style.display = 'block';
            }
            
            // Update selected info display
            updateSelectedInfo();
            
        }

        function loadSystemData() {
            
            // Load vehicles from Types of Vehicles (admin system)
            const savedVehicles = localStorage.getItem('taxiVehicles');
            if (savedVehicles) {
                vehicles = JSON.parse(savedVehicles);
            } else {
                createDefaultVehicles();
            }

            // Load pricing from Distance & Time Pricing (admin system) - prioritize admin data
            let adminPricing = localStorage.getItem('vehiclePricing');
            let bookingPricing = localStorage.getItem('bookingSystemPricing');
            
            if (adminPricing) {
                // Use admin panel pricing data (preferred)
                pricingData = JSON.parse(adminPricing);
                console.log('‚úÖ Loading pricing from admin panel (Distance & Time Pricing)');
                console.log('üí∞ Admin pricing data:', pricingData);
            } else if (bookingPricing) {
                // Fallback to booking system pricing data
                const bookingData = JSON.parse(bookingPricing);
                pricingData = {};
                Object.keys(bookingData).forEach(vehicleId => {
                    pricingData[vehicleId] = {
                        minimumPrice: bookingData[vehicleId].minimumPrice,
                        pricePerKm: bookingData[vehicleId].pricePerKm
                    };
                });
                console.log('‚ö†Ô∏è Loading pricing from booking system fallback');
            } else {
                // Last resort: create defaults
                console.log('‚ùå No admin pricing found, creating defaults');
                createDefaultPricing();
            }

            setTimeout(() => {
                renderVehicles();
                // Run vehicle filtering after vehicles are loaded and rendered
                console.log('üîÑ Running vehicle filtering after data load...');
                filterAndRenderVehicles();
                
                // Check for last-minute booking after rendering
                console.log('‚ö° Checking for last-minute booking after render...');
                checkLastMinuteBooking();
            }, 500);
        }

        function createDefaultVehicles() {
            vehicles = [
                {
                    id: 'saloon',
                    name: 'Saloon',
                    description: 'Comfort sedan voor dagelijks gebruik',
                    active: true,
                    capacity: { passengers: 4, luggage: 2 },
                    image: ''
                },
                {
                    id: 'estate',
                    name: 'Estate',
                    description: 'Ruime stationwagen met extra bagageruimte',
                    active: true,
                    capacity: { passengers: 4, luggage: 4 },
                    image: null
                },
                {
                    id: 'minivan',
                    name: 'Minivan',
                    description: 'Ideaal voor kleine groepen',
                    active: true,
                    capacity: { passengers: 6, luggage: 4 },
                    image: null
                },
                {
                    id: 'minivan_long',
                    name: 'Minivan Long',
                    description: 'Grote groepsvervoer met maximum comfort',
                    active: true,
                    capacity: { passengers: 8, luggage: 6 },
                    image: null
                }
            ];
            
            localStorage.setItem('taxiVehicles', JSON.stringify(vehicles));
            updateStatus('‚úÖ Default voertuigen aangemaakt', '#ffc107');
        }

        function createDefaultPricing() {
            // First check if admin has set pricing
            const adminPricing = JSON.parse(localStorage.getItem('vehiclePricing') || '{}');
            
            // If admin pricing exists, use that - otherwise use defaults
            if (Object.keys(adminPricing).length > 0) {
                console.log('üí∞ Using admin-configured pricing from Distance & Time Pricing');
                pricingData = adminPricing;
                return;
            }
            
            // Fallback to defaults if no admin pricing
            console.log('üí∞ Using default pricing (admin not configured)');
            pricingData = {
                saloon: { minimumPrice: 45.00, pricePerKm: 1.50 },
                estate: { minimumPrice: 55.00, pricePerKm: 1.80 },
                minivan: { minimumPrice: 65.00, pricePerKm: 2.00 },
                minivan_long: { minimumPrice: 85.00, pricePerKm: 2.50 }
            };
            
            localStorage.setItem('vehiclePricing', JSON.stringify(pricingData));
            updateStatus('‚úÖ Default pricing aangemaakt', '#ffc107');
        }

        // Auto-sync pricing updates from admin panel
        function checkForPricingUpdates() {
            const lastUpdateTime = localStorage.getItem('pricingLastUpdate');
            const currentAdminPricing = localStorage.getItem('vehiclePricing');
            
            if (currentAdminPricing) {
                const adminData = JSON.parse(currentAdminPricing);
                
                // Check if admin data differs from current data
                const currentData = JSON.stringify(pricingData);
                const adminDataString = JSON.stringify(adminData);
                
                if (currentData !== adminDataString) {
                    console.log('üîÑ Admin pricing data updated, refreshing...');
                    pricingData = adminData;
                    
                    // Show update notification - DISABLED for customers
                    // showPricingUpdateNotification();
                    
                    // Re-render vehicles with new pricing
                    recalculateVehiclePrices();
                }
            }
        }

        function showPricingUpdateNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed; top: 20px; right: 20px; background: #28a745; color: white;
                padding: 15px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 1000; font-size: 14px; font-weight: 600; max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            notification.innerHTML = 'üîÑ Prijzen bijgewerkt vanuit Admin Distance & Time Pricing';
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), 3000);
        }

        function renderVehicles() {
            renderVehicleGrid('vehicleGridOutbound', 'outbound');
            if (hasReturnTrip) {
                renderVehicleGrid('vehicleGridReturn', 'return');
            }
        }

        function renderVehicleGrid(gridId, tripType) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';

            // ‚ö° Calculate last-minute surcharge ONCE for all vehicles
            let globalLastMinuteSurcharge = 0;
            let isLastMinute = false;
            const travelDate = localStorage.getItem('travelDate');
            const travelHour = localStorage.getItem('travelHour');
            const travelMinute = localStorage.getItem('travelMinute');
            
            if (travelDate && travelHour && travelMinute) {
                const lastMinuteCheck = isLastMinuteBooking(travelDate, travelHour, travelMinute);
                isLastMinute = lastMinuteCheck.isLastMinute;
                console.log(`‚ö° GLOBAL last-minute check for ALL vehicles:`, lastMinuteCheck);
            }

            // Filter active vehicles and sort with Saloon first
            const activeVehicles = vehicles
                .filter(vehicle => vehicle.active !== false)
                .sort((a, b) => {
                    // Force Saloon to be first
                    if (a.id === 'saloon' && b.id !== 'saloon') return -1;
                    if (b.id === 'saloon' && a.id !== 'saloon') return 1;
                    // If both are saloon or neither is saloon, sort alphabetically
                    return a.name.localeCompare(b.name);
                });

            if (activeVehicles.length === 0) {
                grid.innerHTML = `
                    <div class="loading">
                        <h3>‚ö†Ô∏è Geen actieve voertuigen</h3>
                        <p>Configureer voertuigen in Admin ‚Üí Types of Vehicles</p>
                        <!-- <a href="admin-simple.html" target="_blank" class="admin-link"> OUDE VERSIE -->
                        <a href="admin-drivers.html" target="_blank" class="admin-link">
                            üîß Open Admin Panel
                        </a>
                    </div>
                `;
                return;
            }

            activeVehicles.forEach(vehicle => {
                const basePricing = pricingData[vehicle.id] || { minimumPrice: 50.00, pricePerKm: 2.00 };
                // Add vehicle ID to pricing data for distance-based calculations
                basePricing.vehicleId = vehicle.id;
                const pricing = calculateDistanceBasedPricing(basePricing);
                
                const card = document.createElement('div');
                card.className = 'vehicle-card';
                card.onclick = (event) => {
                    console.log(`üîç Vehicle card clicked: ${vehicle.name}`);
                    selectVehicle(vehicle, pricing, tripType, event.currentTarget);
                };
                
                // Check if this vehicle is selected for this trip type
                const isSelected = (tripType === 'outbound' && selectedVehicleOutbound?.vehicle.id === vehicle.id) ||
                                  (tripType === 'return' && selectedVehicleReturn?.vehicle.id === vehicle.id);
                
                if (isSelected) {
                    card.classList.add('selected');
                }
                
                // Professional vehicle descriptions (NO external images)
                const professionalVehicles = {
                    'saloon': {
                        image: null, // No external images
                        description: ''
                    },
                    'estate': {
                        image: null, // No external images
                        description: ''
                    },
                    'minivan': {
                        image: null, // No external images
                        description: ''
                    },
                    'minivan_long': {
                        image: null, // No external images
                        description: ''
                    }
                };

                // Determine image and description
                let imageContent, vehicleDescription, vehicleFeatures;
                
                // Try to get vehicle data from Vehicle Manager (localStorage)
                const vehicleManagerData = JSON.parse(localStorage.getItem('taxiVehicles') || '[]');
                const vehicleManagerVehicle = vehicleManagerData.find(v => v.id === vehicle.id);
                
                // Use Vehicle Manager image if available, otherwise fallback to professional images
                let imageToUse, descriptionToUse;
                
                if (vehicleManagerVehicle && vehicleManagerVehicle.image) {
                    // Use Vehicle Manager image and description
                    imageToUse = vehicleManagerVehicle.image;
                    descriptionToUse = vehicleManagerVehicle.description || vehicle.description;
                } else {
                    // NO fallback images - leave empty
                    imageToUse = null;
                    const professional = professionalVehicles[vehicle.id] || professionalVehicles['saloon'];
                    descriptionToUse = professional.description;
                }
                
                // Create image content - only if image exists
                if (imageToUse) {
                    imageContent = `<img src="${imageToUse}" alt="${vehicle.name}" style="width: 100%; height: 100%; object-fit: cover; object-position: center; border-radius: 10px; transition: all 0.3s ease;">`;
                } else {
                    // No image - show empty placeholder with vehicle name
                    imageContent = `<div style="width: 100%; height: 100%; background: #f8f9fa; border: 2px dashed #dee2e6; border-radius: 10px; display: flex; align-items: center; justify-content: center; color: #6c757d; font-size: 14px; text-align: center;">${vehicle.name}<br><small>Geen afbeelding</small></div>`;
                }
                
                vehicleDescription = descriptionToUse;
                vehicleFeatures = [];
                
                // Get baggage info based on vehicle type
                const bagageInfo = getBagageInfo(vehicle.id);
                
                // Calculate price and label based on trip type
                let displayPrice, displayLabel, priceDetails = '';
                
                if (hasReturnTrip) {
                    const returnPrice = Math.ceil(pricing.minimumPrice * 2); // Round up double price
                    if (tripType === 'outbound') {
                        displayPrice = returnPrice; // Already whole number
                        displayLabel = 'Heen & Terug';
                    } else {
                        displayPrice = returnPrice; // Already whole number
                        displayLabel = 'Heen & Terug';
                    }
                } else {
                    displayPrice = pricing.minimumPrice; // Already rounded up to whole number
                    displayLabel = 'Enkele reis';
                    
                    // Price calculation details hidden from customers
                    // Only show final price, not the breakdown
                }
                
                // ‚ö° Apply global last-minute surcharge to ALL vehicles
                let priceHTML = '';
                if (isLastMinute) {
                    const lastMinuteSurcharge = calculateLastMinuteSurcharge(displayPrice);
                    const originalPrice = displayPrice;
                    const newPrice = Math.ceil(displayPrice + lastMinuteSurcharge);
                    
                    // Update price but don't show last-minute info
                    displayPrice = newPrice;
                    console.log(`‚ö° VEHICLE ${vehicle.name} - Last-minute surcharge: ‚Ç¨${originalPrice} + ‚Ç¨${lastMinuteSurcharge.toFixed(2)} = ‚Ç¨${newPrice}`);
                }
                
                // Always show simple single price
                priceHTML = `‚Ç¨${displayPrice}`;
                
                card.innerHTML = `
                    <div class="vehicle-left">
                        <div class="vehicle-image">
                            ${imageContent}
                        </div>
                        <div class="vehicle-details">
                            <div class="vehicle-name">${vehicle.name}</div>
                            <div class="vehicle-description" style="font-size: 12px; color: #666; margin: 8px 0; line-height: 1.4;">
                                ${vehicleDescription}
                            </div>
                            <div class="vehicle-specs">
                                <div class="spec-item">
                                    <span class="spec-icon">üë•</span>
                                    <span>${bagageInfo.passengers} Passengers</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-icon">üß≥</span>
                                    <span>${bagageInfo.luggages} Luggages</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-icon">üíº</span>
                                    <span>${bagageInfo.bags} Bags</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="vehicle-right">
                        <div class="vehicle-price">${priceHTML}</div>
                        <div class="trip-type">${displayLabel}</div>
                    </div>
                `;
                
                grid.appendChild(card);
            });

        }

        function selectVehicle(vehicle, pricing, tripType, cardElement = null) {
            console.log(`üöó selectVehicle called: ${vehicle.name}, tripType: ${tripType}`);
            
            // Remove previous selection from current trip type grid
            const currentGrid = tripType === 'outbound' ? 'vehicleGridOutbound' : 'vehicleGridReturn';
            const grid = document.getElementById(currentGrid);
            
            if (grid) {
                document.querySelectorAll(`#${currentGrid} .vehicle-card`).forEach(card => {
                    card.classList.remove('selected');
                });

                // Select the clicked card directly if provided
                if (cardElement) {
                    cardElement.classList.add('selected');
                    console.log(`üöó Vehicle card selected via cardElement: ${vehicle.name}`);
                } else {
                    // Fallback: Find and select the vehicle card by name
                    const vehicleCards = grid.querySelectorAll('.vehicle-card');
                    vehicleCards.forEach(card => {
                        const cardText = card.textContent || card.innerText;
                        if (cardText.includes(vehicle.name)) {
                            card.classList.add('selected');
                            console.log(`üöó Vehicle card selected via fallback: ${vehicle.name}`);
                        }
                    });
                }
            } else {
                console.error(`üöó Grid not found: ${currentGrid}`);
            }
            
            // Store selection for the appropriate trip type
            if (tripType === 'outbound') {
                selectedVehicleOutbound = { vehicle, pricing, tripType };
                console.log(`üöó Selected Outbound Vehicle: ${vehicle.name} - Base Price: ‚Ç¨${pricing.minimumPrice.toFixed(2)}`);
            } else {
                selectedVehicleReturn = { vehicle, pricing, tripType };
                console.log(`üöó Selected Return Vehicle: ${vehicle.name} - Base Price: ‚Ç¨${pricing.minimumPrice.toFixed(2)}`);
            }

            // Do NOT automatically update passenger count - user should control this
            // updatePassengerCountForVehicle(vehicle.id); // Disabled - let user choose

            // Update selected info display
            updateSelectedInfo();

            // Update continue button state
            updateContinueButton();

            // Show surcharge section when vehicle is selected
            showSurchargeSection();

            // Update surcharge totals after vehicle selection
            updateSurchargeTotal();

        }

        function updateSelectedInfo() {
            console.log(`üîÑ updateSelectedInfo called, currentTripType: ${currentTripType}`);
            console.log(`üîÑ selectedVehicleOutbound:`, selectedVehicleOutbound);
            console.log(`üîÑ selectedVehicleReturn:`, selectedVehicleReturn);
            
            const selectedInfo = document.getElementById('selectedInfo');
            const selectedName = document.getElementById('selectedVehicleName');
            const selectedMinPrice = document.getElementById('selectedMinPrice');
            
            if (currentTripType === 'outbound' && selectedVehicleOutbound) {
                selectedName.textContent = selectedVehicleOutbound.vehicle.name;
                selectedInfo.style.display = 'block';
                // Let updateTotalPrice handle the price calculation with surcharges
                updateTotalPrice();
            } else if (currentTripType === 'return' && selectedVehicleReturn) {
                selectedName.textContent = selectedVehicleReturn.vehicle.name;
                selectedInfo.style.display = 'block';
                // Let updateTotalPrice handle the price calculation with surcharges
                updateTotalPrice();
            } else {
                selectedInfo.style.display = 'none';
                selectedMinPrice.textContent = '';
            }
        }

        function updateContinueButton() {
            const continueBtn = document.getElementById('continueBtn');
            
            if (hasReturnTrip) {
                // For return trips, both outbound and return vehicles must be selected
                continueBtn.disabled = !(selectedVehicleOutbound && selectedVehicleReturn);
            } else {
                // For single trips, only outbound vehicle is needed
                continueBtn.disabled = !selectedVehicleOutbound;
            }
        }

        function updatePassengerCountForVehicle(vehicleId) {
            let suggestedPassengers = 1;
            let suggestedKoffers = 2;
            let suggestedHandbagage = 2;
            let recommendationText = '';

            // Set counts based on vehicle type
            switch(vehicleId) {
                case 'saloon':
                    suggestedPassengers = 4; // Fixed: was 3, now 4 to match admin
                    suggestedKoffers = 2;
                    suggestedHandbagage = 2;
                    recommendationText = 'Saloon: ideaal voor 1-4 passagiers';
                    break;
                case 'estate':
                    suggestedPassengers = 4;
                    suggestedKoffers = 3;
                    suggestedHandbagage = 3;
                    recommendationText = 'Estate: ideaal voor 4 passagiers';
                    break;
                case 'minivan':
                    suggestedPassengers = 6;
                    suggestedKoffers = 6;
                    suggestedHandbagage = 6;
                    recommendationText = 'Minivan: ideaal voor 5-6 passagiers';
                    break;
                case 'minivan_long':
                    suggestedPassengers = 8;
                    suggestedKoffers = 8;
                    suggestedHandbagage = 8;
                    recommendationText = 'Minivan Long: ideaal voor 7-8 passagiers';
                    break;
            }

            // Update counter displays
            counters.passengers = suggestedPassengers;
            counters.koffers = suggestedKoffers;
            counters.handbagage = suggestedHandbagage;
            document.getElementById('passengersCount').textContent = suggestedPassengers;
            document.getElementById('koffersCount').textContent = suggestedKoffers;
            document.getElementById('handbagageCount').textContent = suggestedHandbagage;
            
            localStorage.setItem('selectedPassengers', suggestedPassengers);
            localStorage.setItem('selectedKoffers', suggestedKoffers);
            localStorage.setItem('selectedHandbagage', suggestedHandbagage);
            
            // Update recommendation text
            const recommendation = document.getElementById('passengerRecommendation');
            recommendation.textContent = recommendationText;
            
        }

        function continueToStep3() {
            if (hasReturnTrip) {
                if (!selectedVehicleOutbound || !selectedVehicleReturn) {
                    alert('‚ö†Ô∏è Selecteer voertuigen voor zowel heen als terug reis');
                    return;
                }
            } else {
                if (!selectedVehicleOutbound) {
                    alert('‚ö†Ô∏è Selecteer eerst een voertuig');
                    return;
                }
            }

            // Save selections for STAP 3
            const vehicleSelections = {
                outbound: selectedVehicleOutbound,
                return: selectedVehicleReturn,
                hasReturnTrip: hasReturnTrip
            };
            
            localStorage.setItem('selectedVehicleStep2', JSON.stringify(vehicleSelections));
            
            // Save additional passenger details
            const passengerDetails = {
                passengers: counters.passengers,
                koffers: counters.koffers,
                handbagage: counters.handbagage
            };
            localStorage.setItem('passengerDetails', JSON.stringify(passengerDetails));

            // Save selected surcharges including automatic stopover charges
            const extraStopCount = parseInt(localStorage.getItem('extraStopCount') || '0');
            let automaticStopoverCharges = {};
            
            if (extraStopCount > 0) {
                const stopoverItem = surchargeItems.fixed.find(item => item.id === 'stopover');
                if (stopoverItem) {
                    let stopoverTotal = stopoverItem.price * extraStopCount;
                    let effectiveQuantity = extraStopCount;
                    
                    // For return trips, double the stopover charges
                    if (hasReturnTrip) {
                        stopoverTotal = stopoverTotal * 2;
                        effectiveQuantity = extraStopCount * 2; // Show total stops for both directions
                    }
                    
                    automaticStopoverCharges = {
                        'stopover': {
                            name: stopoverItem.name,
                            price: stopoverItem.price,
                            quantity: effectiveQuantity,
                            type: 'automatic',
                            total: stopoverTotal,
                            isReturnTrip: hasReturnTrip
                        }
                    };
                }
            }
            
            const surchargeData = {
                selectedSurcharges: selectedSurcharges,
                automaticCharges: automaticStopoverCharges,
                surchargeTotal: surchargeTotal,
                extraStopCount: extraStopCount
            };
            localStorage.setItem('selectedSurcharges', JSON.stringify(surchargeData));

            
            // Go to STAP 3
            window.location.href = 'step3.html';
        }

        function goBack() {
            window.location.href = 'booking-exact.html';
        }
        
        function goToStep(stepNumber) {
            if (stepNumber === 1) {
                window.location.href = 'booking-exact.html';
            } else if (stepNumber === 3) {
                if (selectedVehicleOutbound) {
                    window.location.href = 'step3.html';
                } else {
                    alert('Selecteer eerst een voertuig');
                }
            }
        }

        // Test connection with admin systems
        function testAdminConnection() {
            const vehicleCount = vehicles.length;
            const pricingCount = Object.keys(pricingData).length;
            
            console.log('üîó Admin Connection Test:');
            console.log('üìã Types of Vehicles:', vehicleCount, 'vehicles');
            console.log('üí∞ Distance & Time Pricing:', pricingCount, 'configurations');
            console.log('üîÑ Data sync successful');
        }

        // Run connection test after load
        setTimeout(testAdminConnection, 1000);

        // Counter controls functionality
        let counters = {
            passengers: 1,
            koffers: 0,
            handbagage: 0
        };

        // Initialize counters from localStorage or defaults
        function initializeCounters() {
            console.log('üî¢ Initializing counters...');
            
            // Load from localStorage if available
            const savedPassengers = localStorage.getItem('selectedPassengers');
            const savedKoffers = localStorage.getItem('selectedKoffers');
            const savedHandbagage = localStorage.getItem('selectedHandbagage');
            
            if (savedPassengers) {
                counters.passengers = parseInt(savedPassengers) || 1;
            }
            if (savedKoffers) {
                counters.koffers = parseInt(savedKoffers) || 0;
            }
            if (savedHandbagage) {
                counters.handbagage = parseInt(savedHandbagage) || 0;
            }
            
            console.log('üî¢ Counters initialized:', counters);
            
            // Update display
            document.getElementById('passengersCount').textContent = counters.passengers;
            document.getElementById('koffersCount').textContent = counters.koffers;
            document.getElementById('handbagageCount').textContent = counters.handbagage;
            
            console.log('üî¢ Counter displays updated');
        }

        function changeCount(type, delta) {
            console.log(`üî¢ changeCount called: ${type}, delta: ${delta}`);
            console.log(`üî¢ Current counters:`, counters);
            
            const current = counters[type];
            let newValue = current + delta;
            
            console.log(`üî¢ Current value: ${current}, New value before limits: ${newValue}`);
            
            // Set limits
            if (type === 'passengers') {
                newValue = Math.max(1, Math.min(8, newValue));
            } else if (type === 'koffers' || type === 'handbagage') {
                newValue = Math.max(0, Math.min(8, newValue));
            }
            
            console.log(`üî¢ Final new value: ${newValue}`);
            
            counters[type] = newValue;
            
            // Update display
            const element = document.getElementById(`${type}Count`);
            if (element) {
                element.textContent = newValue;
                console.log(`üî¢ Updated ${type}Count display to: ${newValue}`);
            } else {
                console.error(`üî¢ Element ${type}Count not found!`);
            }
            
            // Save to localStorage
            localStorage.setItem('selectedPassengers', counters.passengers);
            localStorage.setItem('selectedKoffers', counters.koffers);
            localStorage.setItem('selectedHandbagage', counters.handbagage);
            
            console.log(`üî¢ Saved to localStorage:`, {
                passengers: counters.passengers,
                koffers: counters.koffers, 
                handbagage: counters.handbagage
            });
            
            // Trigger vehicle filtering for any counter change
            filterAndRenderVehicles();
        }

        // Filter and render vehicles based on passenger/luggage requirements
        function filterAndRenderVehicles() {
            const passengers = counters.passengers;
            const koffers = counters.koffers;
            const handbagage = counters.handbagage;
            
            console.log(`üîç Filtering vehicles for: ${passengers} passengers, ${koffers} koffers, ${handbagage} handbagage`);
            
            // Dynamic vehicle selection based on actual vehicle capacities
            const recommendation = document.getElementById('passengerRecommendation');
            let recommendedVehicle = null;

            // Get actual vehicle capacities from Vehicle-manager configuration
            const vehicleCapacities = {};
            vehicles.forEach(vehicle => {
                const bagageInfo = getBagageInfo(vehicle.id); // Use existing function
                vehicleCapacities[vehicle.id] = {
                    passengers: bagageInfo.passengers,
                    koffers: bagageInfo.luggages,
                    handbagage: bagageInfo.bags
                };
                console.log(`üöó Vehicle ${vehicle.id} (${vehicle.name}) capacity: ${bagageInfo.passengers} passengers, ${bagageInfo.luggages} koffers, ${bagageInfo.bags} handbagage`);
            });

            // Find best vehicle based on actual capacities (koffers AND handbagage separately)
            let bestVehicle = null;
            let bestScore = -1;

            vehicles.filter(v => v.active !== false).forEach(vehicle => {
                const capacity = vehicleCapacities[vehicle.id];
                let score = 0;

                // Check if vehicle can handle ALL requirements separately
                const canHandlePassengers = capacity.passengers >= passengers;
                const canHandleKoffers = capacity.koffers >= koffers;
                const canHandleHandbagage = capacity.handbagage >= handbagage;
                
                console.log(`üöó Testing ${vehicle.name}: passengers ${capacity.passengers}>=${passengers}=${canHandlePassengers}, koffers ${capacity.koffers}>=${koffers}=${canHandleKoffers}, handbagage ${capacity.handbagage}>=${handbagage}=${canHandleHandbagage}`);

                if (canHandlePassengers && canHandleKoffers && canHandleHandbagage) {
                    // Give higher score to vehicles that fit better (not oversized)
                    score = 1000 
                        - Math.abs(capacity.passengers - passengers) * 10
                        - Math.abs(capacity.koffers - koffers) * 5  
                        - Math.abs(capacity.handbagage - handbagage) * 5;
                    
                    console.log(`‚úÖ ${vehicle.name} can handle requirements, score: ${score}`);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestVehicle = vehicle;
                        console.log(`üèÜ New best vehicle: ${vehicle.name} (score: ${score})`);
                    }
                } else {
                    console.log(`‚ùå ${vehicle.name} cannot handle requirements`);
                }
            });

            if (bestVehicle) {
                const capacity = vehicleCapacities[bestVehicle.id];
                let reasonParts = [];
                
                if (passengers > 1) {
                    reasonParts.push(`${passengers} passagiers`);
                }
                if (koffers > 0) {
                    reasonParts.push(`${koffers} koffers`);
                }
                if (handbagage > 0) {
                    reasonParts.push(`${handbagage} handbagage`);
                }
                
                const reason = reasonParts.length > 0 ? `(${reasonParts.join(', ')})` : '';
                
                recommendation.textContent = `‚úÖ Aanbevolen: ${bestVehicle.name} ${reason}`;
                recommendedVehicle = bestVehicle.id;
                
                console.log(`üéØ Recommended vehicle: ${bestVehicle.name} for ${reason}`);
                
            } else {
                // No vehicle can handle requirements - recommend largest vehicle
                const largestVehicle = vehicles
                    .filter(v => v.active !== false)
                    .sort((a, b) => {
                        const aCapacity = vehicleCapacities[a.id];
                        const bCapacity = vehicleCapacities[b.id];
                        return (bCapacity.passengers + bCapacity.koffers + bCapacity.handbagage) - 
                               (aCapacity.passengers + aCapacity.koffers + aCapacity.handbagage);
                    })[0];
                
                if (largestVehicle) {
                    recommendation.textContent = `‚ö†Ô∏è ${largestVehicle.name} (grootste beschikbare - vereisten te hoog)`;
                    recommendedVehicle = largestVehicle.id;
                    console.log(`‚ö†Ô∏è No vehicle can handle requirements, recommending largest: ${largestVehicle.name}`);
                } else {
                    recommendation.textContent = '‚ö†Ô∏è Geen voertuigen beschikbaar';
                    recommendedVehicle = null;
                    console.log(`‚ùå No vehicles available`);
                }
            }

            // Re-render vehicles to reflect changes
            renderVehicles();

            // Auto-select recommended vehicle AND highlight it
            setTimeout(() => {
                if (recommendedVehicle) {
                    console.log(`üéØ Auto-selecting recommended vehicle: ${recommendedVehicle}`);
                    autoSelectRecommendedVehicle(recommendedVehicle);
                    highlightRecommendedVehicle(recommendedVehicle);
                } else {
                    console.log(`‚ùå No vehicle to auto-select`);
                }
            }, 300);
        }

        // Highlight recommended vehicle without auto-selecting
        function highlightRecommendedVehicle(vehicleId) {
            // Remove previous recommendations
            document.querySelectorAll('.vehicle-card').forEach(card => {
                card.classList.remove('recommended');
            });

            if (vehicleId) {
                // Add recommendation highlight to suggested vehicle
                const targetCard = document.querySelector(`[onclick*="${vehicleId}"]`);
                if (targetCard) {
                    targetCard.classList.add('recommended');
                }
            }
        }

        // Passenger selection functionality
        function selectPassengers(count) {
            // Update counter display
            counters.passengers = parseInt(count);
            document.getElementById('passengersCount').textContent = count;

            // Save passenger count
            localStorage.setItem('selectedPassengers', count);

            // Use the new filtering function
            filterAndRenderVehicles();
        }

        function autoSelectRecommendedVehicle(vehicleId) {
            console.log(`üéØ autoSelectRecommendedVehicle called for: ${vehicleId}`);
            const targetVehicle = vehicles.find(v => v.id === vehicleId);
            
            if (targetVehicle) {
                console.log(`‚úÖ Found target vehicle: ${targetVehicle.name}`);
                const basePricing = pricingData[vehicleId] || { minimumPrice: 50.00, pricePerKm: 2.00 };
                const pricing = calculateDistanceBasedPricing(basePricing);
                
                console.log(`üí∞ Pricing calculated: ‚Ç¨${pricing.minimumPrice}`);
                
                // Auto-select for outbound trip
                console.log(`üöó Auto-selecting for outbound trip`);
                selectVehicleForTrip(targetVehicle, pricing, 'outbound');
                
                // If return trip exists, auto-select same vehicle for return trip
                if (hasReturnTrip) {
                    console.log(`üîÑ Auto-selecting for return trip as well`);
                    selectVehicleForTrip(targetVehicle, pricing, 'return');
                }
                
            } else {
                console.error(`‚ùå Vehicle not found: ${vehicleId}`);
            }
        }

        function selectVehicleForTrip(vehicle, pricing, tripType) {
            // Store selection
            if (tripType === 'outbound') {
                selectedVehicleOutbound = { vehicle, pricing, tripType };
            } else {
                selectedVehicleReturn = { vehicle, pricing, tripType };
            }
            
            // Update visual selection in the appropriate grid
            const gridId = tripType === 'outbound' ? 'vehicleGridOutbound' : 'vehicleGridReturn';
            const grid = document.getElementById(gridId);
            
            // Remove previous selections in this grid
            grid.querySelectorAll('.vehicle-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Find and select the matching card
            const activeVehicles = vehicles.filter(v => v.active !== false);
            const vehicleIndex = activeVehicles.findIndex(v => v.id === vehicle.id);
            
            if (vehicleIndex !== -1) {
                const targetCard = grid.querySelectorAll('.vehicle-card')[vehicleIndex];
                if (targetCard) {
                    targetCard.classList.add('selected');
                }
            }
            
            // Update UI state
            updateSelectedInfo();
            updateContinueButton();
        }

        function disableIncompatibleVehicles(passengerCount) {
            const outboundCards = document.querySelectorAll('#vehicleGridOutbound .vehicle-card');
            const returnCards = document.querySelectorAll('#vehicleGridReturn .vehicle-card');
            const activeVehicles = vehicles.filter(vehicle => vehicle.active !== false);

            [outboundCards, returnCards].forEach(cardsList => {
                cardsList.forEach((card, index) => {
                    const vehicle = activeVehicles[index];
                    if (vehicle) {
                        // For 7-8 passengers, only Minivan Long is allowed
                        if (passengerCount >= 7 && vehicle.id !== 'minivan_long') {
                            card.classList.add('disabled');
                            // Remove selection if this card was selected
                            if (card.classList.contains('selected')) {
                                card.classList.remove('selected');
                                
                                // Clear appropriate selection
                                if (card.closest('#vehicleGridOutbound')) {
                                    selectedVehicleOutbound = null;
                                } else if (card.closest('#vehicleGridReturn')) {
                                    selectedVehicleReturn = null;
                                }
                                
                                updateSelectedInfo();
                                updateContinueButton();
                            }
                        }
                    }
                });
            });
        }

        function enableAllVehicles() {
            const allCards = document.querySelectorAll('.vehicle-card');
            allCards.forEach(card => {
                card.classList.remove('disabled');
            });
        }

        function getBagageInfo(vehicleId) {
            // Try to get capacity from admin vehicle configuration first
            const savedVehicles = localStorage.getItem('taxiVehicles');
            if (savedVehicles) {
                try {
                    const vehicles = JSON.parse(savedVehicles);
                    const vehicle = vehicles.find(v => v.id === vehicleId);
                    if (vehicle) {
                        // Use admin configured values from capacity object, with fallbacks
                        const passengers = vehicle.capacity?.passengers || vehicle.passengers || 4;
                        const luggages = vehicle.capacity?.luggage || vehicle.luggage || 2;
                        const bags = vehicle.capacity?.handLuggage || vehicle.handBags || 2;
                        
                        console.log(`üìä Using admin capacity for ${vehicleId}: ${passengers} passengers, ${luggages} luggage, ${bags} bags`);
                        
                        return {
                            passengers: passengers,
                            luggages: luggages,
                            bags: bags
                        };
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not load vehicle capacity from admin config:', e);
                }
            }
            
            // Fallback to corrected values if admin config not available
            const bagageCapacity = {
                'saloon': { passengers: 4, luggages: 2, bags: 2 }, // Fixed: was 3, now 4 to match admin
                'estate': { passengers: 4, luggages: 3, bags: 3 },
                'minivan': { passengers: 6, luggages: 6, bags: 6 },
                'minivan_long': { passengers: 8, luggages: 8, bags: 8 }
            };
            
            return bagageCapacity[vehicleId] || { passengers: 4, luggages: 2, bags: 2 };
        }

        // Route and Maps functionality
        function loadRouteInfo() {
            const fromLocation = localStorage.getItem('fromLocation') || 'Niet ingevuld';
            const toLocation = localStorage.getItem('toLocation') || 'Niet ingevuld';
            
            // Update route display
            document.getElementById('routeFrom').textContent = fromLocation;
            document.getElementById('routeTo').textContent = toLocation;
            
            if (fromLocation !== 'Niet ingevuld' && toLocation !== 'Niet ingevuld') {
                // Try to load route with fallback
                calculateRouteWithFallback(fromLocation, toLocation);
            }
        }

        function loadRouteInfoFromStep1() {
            console.log('üìç Loading route info from STAP 1...');
            
            const fromLocation = localStorage.getItem('fromLocation');
            const toLocation = localStorage.getItem('toLocation');
            
            console.log('üìç From localStorage - Van:', fromLocation);
            console.log('üìç From localStorage - Naar:', toLocation);
            
            if (fromLocation && toLocation) {
                // Update the display immediately
                const fromElement = document.querySelector('#mapLoading div:nth-child(2)');
                const toElement = document.querySelector('#mapLoading div:nth-child(3)');
                
                if (fromElement) fromElement.textContent = `Van: ${fromLocation}`;
                if (toElement) toElement.textContent = `Naar: ${toLocation}`;
                
                console.log('‚úÖ Route info updated in display');
                
                // Also trigger route calculation with the loaded locations
                setTimeout(() => {
                    console.log('üîÑ Triggering route calculation...');
                    calculateRouteWithFallback(fromLocation, toLocation);
                }, 1000);
                
            } else {
                console.error('‚ùå No route info found in localStorage');
                console.log('üìç Available localStorage keys:', Object.keys(localStorage));
            }
        }

        function calculateRouteWithFallback(from, to) {
            console.log('üìç calculateRouteWithFallback called with:', from, to);
            
            // First try with Google Maps (if API key available)
            if (typeof google !== 'undefined' && google.maps) {
                console.log('üìç Using Google Maps for route calculation');
                initializeGoogleMapsRoute(from, to);
            } else {
                console.log('üìç Google Maps not available, using fallback');
                calculateSimpleRoute(from, to);
                // Optionally load Google Maps API
                loadGoogleMapsAPI();
            }
        }

        function calculateSimpleRoute(from, to) {
            // Use configured known routes or fallback
            const knownRoutes = GOOGLE_MAPS_CONFIG?.knownRoutes || {
                'leuven-brussels': { distance: '28 km', duration: '35 min' },
                'leuven-willebroek': { distance: '50 km', duration: '45 min' },
                'brussels-zaventem': { distance: '15 km', duration: '20 min' }
            };
            
            // Try to match known routes
            const routeKey = createRouteKey(from, to);
            const route = knownRoutes[routeKey];
            
            if (route) {
                document.getElementById('routeDistance').textContent = route.distance;
                document.getElementById('routeDuration').textContent = route.duration;
                document.getElementById('routeType').textContent = 'Geschatte route';
                
                // üÜï Extract distance for pricing calculations
                const distanceMatch = route.distance.match(/(\d+(?:\.\d+)?)/);
                if (distanceMatch) {
                    calculatedDistance = parseFloat(distanceMatch[1]);
                    distanceCalculated = true;
                    console.log(`üìè Fallback distance: ${calculatedDistance} km from known route`);
                    console.log('üí∞ Triggering vehicle price recalculation with fallback distance...');
                    recalculateVehiclePrices();
                }
            } else {
                // Default estimation - use middle estimate
                document.getElementById('routeDistance').textContent = '25-50 km (schatting)';
                document.getElementById('routeDuration').textContent = '30-60 min (schatting)';
                document.getElementById('routeType').textContent = 'Schatting - exacte route wordt berekend';
                
                // üÜï Use conservative estimate for pricing
                calculatedDistance = 35; // Middle of 25-50 km range
                distanceCalculated = true;
                console.log(`üìè Using default estimate: ${calculatedDistance} km`);
                console.log('üí∞ Triggering vehicle price recalculation with estimated distance...');
                recalculateVehiclePrices();
            }
            
            // Hide loading, show info message
            document.getElementById('mapLoading').innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 16px; margin-bottom: 10px;">üó∫Ô∏è Route informatie</div>
                    <div style="font-size: 14px; color: #28a745;">Van: ${from}</div>
                    <div style="font-size: 14px; color: #28a745;">Naar: ${to}</div>
                    <div style="font-size: 12px; margin-top: 10px; color: #6c757d;">
                        Exacte route wordt berekend bij bevestiging
                    </div>
                </div>
            `;
        }

        function createRouteKey(from, to) {
            // Normalize city names for route matching
            const normalize = (str) => str.toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z-]/g, '')
                .split('-')[0]; // Take first word (city name)
            
            const fromCity = normalize(from);
            const toCity = normalize(to);
            
            return `${fromCity}-${toCity}`;
        }

        function loadGoogleMapsAPI() {
            // Check if Google Maps is already loaded
            if (typeof google !== 'undefined') {
                console.log('üìç Google Maps API already loaded');
                return Promise.resolve();
            }
            
            // Get API key from admin panel settings
            const googleSettings = JSON.parse(localStorage.getItem('googleSettings') || '{}');
            const apiKey = googleSettings.googleMapsApiKey || 'AIzaSyBAitd_yXcPjG7VcDkiRrfc6IdgXAD5awk'; // fallback key
            
            if (!apiKey || apiKey === 'YOUR_API_KEY_HERE') {
                console.log('‚ö†Ô∏è No valid Google Maps API key found in admin settings');
                console.log('üìç Using fallback route calculation');
                return Promise.reject('No API key');
            }
            
            return new Promise((resolve, reject) => {
                console.log('üìç Loading Google Maps API with admin panel key...');
                
                // Create script element with callback for proper async loading
                window.initGoogleMaps = function() {
                    console.log('üó∫Ô∏è Google Maps callback triggered');
                    
                    // Wait a moment to ensure all APIs are ready
                    setTimeout(() => {
                        if (typeof google !== 'undefined' && google.maps && google.maps.Geocoder) {
                            console.log('‚úÖ All Google Maps APIs ready');
                            resolve();
                        } else {
                            console.error('‚ùå Google Maps APIs not fully loaded in callback');
                            reject(new Error('Google Maps APIs not ready'));
                        }
                    }, 100);
                };
                
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=geometry,places&callback=initGoogleMaps&loading=async`;
                script.async = true;
                script.defer = true;
                
                // Note: resolve() is now called by the callback function initGoogleMaps
                // script.onload is not needed with callback method
                
                // Handle errors
                script.onerror = (error) => {
                    console.error('‚ùå Failed to load Google Maps API:', error);
                    console.log('üìç Falling back to basic route calculation');
                    reject(error);
                };
                
                // Add to page
                document.head.appendChild(script);
            });
        }

        function initializeGoogleMapsRoute(from, to) {
            if (!mapInitialized) {
                // Initialize map
                routeMap = new google.maps.Map(document.getElementById('map'), {
                    zoom: 8,
                    center: { lat: 50.8798, lng: 4.7005 }, // Belgium center
                    styles: [
                        {
                            featureType: 'poi',
                            elementType: 'labels',
                            stylers: [{ visibility: 'off' }]
                        }
                    ]
                });
                
                directionsService = new google.maps.DirectionsService();
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: false,
                    polylineOptions: {
                        strokeColor: '#667eea',
                        strokeWeight: 5
                    }
                });
                
                directionsRenderer.setMap(routeMap);
                mapInitialized = true;
            }
            
            // üÜï ENHANCED: Include extra stops/waypoints in map display
            const extraStopCount = parseInt(localStorage.getItem('extraStopCount')) || 0;
            const waypoints = [];
            
            // Collect all extra stops from localStorage - FIXED: Use extraStops array
            if (extraStopCount > 0) {
                const extraStopsArray = JSON.parse(localStorage.getItem('extraStops') || '[]');
                console.log(`üó∫Ô∏è Found ${extraStopsArray.length} extra stops in localStorage:`, extraStopsArray);
                
                extraStopsArray.forEach((stopLocation, index) => {
                    if (stopLocation && stopLocation.trim()) {
                        waypoints.push({
                            location: stopLocation.trim(),
                            stopover: true
                        });
                        console.log(`üó∫Ô∏è Added waypoint ${index + 1}: ${stopLocation.trim()}`);
                    }
                });
            }
            
            console.log(`üó∫Ô∏è Initializing map with ${waypoints.length} extra stops:`, waypoints);
            
            // Calculate route WITH WAYPOINTS
            const request = {
                origin: from,
                destination: to,
                waypoints: waypoints,
                travelMode: google.maps.TravelMode.DRIVING,
                avoidTolls: false,
                avoidHighways: false,
                optimizeWaypoints: false // Keep original order
            };
            
            directionsService.route(request, (result, status) => {
                if (status === 'OK') {
                    directionsRenderer.setDirections(result);
                    
                    // Calculate total distance and duration for all legs
                    const route = result.routes[0];
                    let totalDistance = 0;
                    let totalDuration = 0;
                    
                    // Sum all legs (A‚ÜíStop1, Stop1‚ÜíStop2, Stop2‚ÜíB, etc.)
                    route.legs.forEach(leg => {
                        totalDistance += leg.distance.value;
                        totalDuration += leg.duration.value;
                    });
                    
                    // Update route info with totals
                    const totalDistanceKm = (totalDistance / 1000).toFixed(1);
                    const totalDurationMin = Math.round(totalDuration / 60);
                    
                    document.getElementById('routeDistance').textContent = `${totalDistanceKm} km`;
                    document.getElementById('routeDuration').textContent = `${totalDurationMin} min`;
                    document.getElementById('routeType').textContent = waypoints.length > 0 ? 
                        `Route met ${waypoints.length} tussenstop${waypoints.length > 1 ? 's' : ''}` : 
                        'Directe route';
                    
                    // üÜï CRITICAL: Store total distance for pricing calculations
                    calculatedDistance = totalDistance / 1000; // Convert meters to kilometers
                    distanceCalculated = true;
                    
                    console.log(`üó∫Ô∏è Google Maps TOTAL distance: ${totalDistanceKm} km (${calculatedDistance.toFixed(2)} km)`);
                    console.log(`üó∫Ô∏è Route legs: ${route.legs.length}, Waypoints: ${waypoints.length}`);
                    console.log('üí∞ Triggering vehicle price recalculation with real distance...');
                    
                    // Recalculate all vehicle prices with real distance
                    recalculateVehiclePrices();
                    
                    // Show map, hide loading
                    document.getElementById('mapLoading').style.display = 'none';
                    document.getElementById('map').style.display = 'block';
                    
                } else {
                    console.log('‚ùå Google Maps route with waypoints failed, trying fallback calculation');
                    calculateSimpleRoute(from, to);
                }
            });
        }

        // Toggle route map visibility
        function toggleRouteMap() {
            const mapSection = document.getElementById('routeMapSection');
            const text = document.getElementById('routeToggleText');
            const isVisible = mapSection.style.display !== 'none';

            if (isVisible) {
                // Hide map
                mapSection.style.display = 'none';
                text.textContent = 'Toon kaart';
            } else {
                // Show map
                mapSection.style.display = 'block';
                text.textContent = 'Verberg kaart';
            }
        }

        // Item Surcharge Management
        let surchargeItems = { fixed: [], additional: [] };
        let selectedSurcharges = {};
        let surchargeTotal = 0;
        let lastSurchargeUpdateTime = 0;

        // Enhanced Meet & Greet check function that uses admin settings
        function checkSimpleMeetAndGreet(location) {
            if (!location) return { required: false };
            
            const loc = location.toLowerCase();
            
            // First, check admin-configured Meet & Greet locations
            const meetAndGreetLocations = JSON.parse(localStorage.getItem('meetAndGreetLocations') || '{}');
            
            // Check if any admin location matches
            for (const [key, locData] of Object.entries(meetAndGreetLocations)) {
                if (locData.enabled && locData.meetGreetEnabled) {
                    // Check if the location contains the configured name
                    if (loc.includes(locData.name.toLowerCase())) {
                        return {
                            required: true,
                            location: locData,
                            instructions: locData.pickupInstructions || `Meet & Greet service at ${locData.name}`
                        };
                    }
                    
                    // Check aliases if available
                    if (locData.aliases && Array.isArray(locData.aliases)) {
                        for (const alias of locData.aliases) {
                            if (loc.includes(alias.toLowerCase())) {
                                return {
                                    required: true,
                                    location: locData,
                                    instructions: locData.pickupInstructions || `Meet & Greet service at ${locData.name}`
                                };
                            }
                        }
                    }
                }
            }
            
            // Fallback: Check by category if enabled in admin
            const meetGreetSettings = JSON.parse(localStorage.getItem('meetGreetCategorySettings') || '{"airports": true, "stations": true, "hotels": false}');
            
            // Check for airports (if category is enabled)
            if (meetGreetSettings.airports) {
                if (loc.includes('airport') || loc.includes('luchthaven') || loc.includes('aeroport') || 
                    loc.includes('flughafen')) {
                    return { 
                        required: true, 
                        location: { name: location },
                        instructions: 'Meet & Greet service at airport pickup'
                    };
                }
            }
            
            // Check for train stations (if category is enabled)
            if (meetGreetSettings.stations) {
                if (loc.includes('station') || loc.includes('central') || loc.includes('gare') || 
                    loc.includes('bahnhof') || loc.includes('centraal')) {
                    return { 
                        required: true, 
                        location: { name: location },
                        instructions: 'Meet & Greet service at station pickup'
                    };
                }
            }
            
            // Check for hotels (if category is enabled)
            if (meetGreetSettings.hotels) {
                if (loc.includes('hotel') || loc.includes('hilton') || loc.includes('marriott') || 
                    loc.includes('ibis') || loc.includes('novotel') || loc.includes('mercure')) {
                    return { 
                        required: true, 
                        location: { name: location },
                        instructions: 'Meet & Greet service at hotel pickup'
                    };
                }
            }
            
            return { required: false };
        }


        function loadSurchargeItems() {
            // Load selected surcharges first
            const savedSurcharges = localStorage.getItem('selectedSurcharges');
            if (savedSurcharges) {
                selectedSurcharges = JSON.parse(savedSurcharges);
            }
            
            // Load Meet & Greet locations from admin localStorage  
            let meetAndGreetLocations = {};
            const savedLocations = localStorage.getItem('meetAndGreetLocations');
            if (savedLocations) {
                meetAndGreetLocations = JSON.parse(savedLocations);
                console.log('‚úÖ Loaded Meet & Greet locations from localStorage:', meetAndGreetLocations);
            } else {
                console.log('‚ö†Ô∏è No Meet & Greet locations found in localStorage');
            }
            
            // First try to load from admin localStorage (primary source)
            let adminSaved = localStorage.getItem('surchargeItems');
            
            // If admin data exists, use it and save to booking localStorage
            if (adminSaved) {
                console.log('üìÑ Loading surcharge items from admin localStorage...');
                console.log('üìÑ Admin surcharge data:', adminSaved);
                surchargeItems = JSON.parse(adminSaved);
                console.log('üìÑ Parsed surcharge items:', surchargeItems);
                localStorage.setItem('bookingSurchargeItems', JSON.stringify(surchargeItems));
                
                // Load Location Surcharges from admin
                loadLocationSurcharges();
            } else {
                // Fallback to booking localStorage or create defaults
                let bookingSaved = localStorage.getItem('bookingSurchargeItems');
                
                if (!bookingSaved) {
                    console.log('üìÑ No surcharge items found, creating default ones...');
                    const defaultSurchargeItems = {
                        fixed: [
                            { id: 'meet-greet', name: 'Meet and greet', price: 0, enabled: true },
                            { id: 'child-seat', name: 'Child seat', price: 3, enabled: true, hasDropdown: true, dropdownOptions: [{ id: 'maxi_cosi', name: 'Maxi Cosi (baby can\'t sit)', price: 0 }, { id: 'baby_seat', name: 'Baby seat', price: 0 }, { id: 'verhoostoel', name: 'Verhoostoel', price: 0 }] },
                            { id: 'dog', name: 'Dog', price: 3, enabled: true, hasDropdown: true, dropdownOptions: [{ id: 'kleine_hond', name: 'Kleine hond', price: 0 }, { id: 'groten_hond', name: 'Groten hond', price: 0 }] },
                            { id: 'wheelchair', name: 'Wheelchair', price: 0, enabled: true },
                            { id: 'waiting-time', name: 'Waiting time after landing', price: 0, enabled: true },
                            { id: 'stopover', name: 'Stopover (Via)', price: 10, enabled: true }
                        ],
                        additional: [
                            { id: 'golf-material', name: 'Golf-material', price: 5, type: 'Amount', quantity: 1 },
                            { id: 'ski-material', name: 'Ski-material', price: 5, type: 'Amount', quantity: 1 },
                            { id: 'water', name: 'Water', price: 2, type: 'Amount', quantity: 1, hasDropdown: true },
                            { id: 'newspaper', name: 'Newspaper', price: 0, type: 'Amount', quantity: 1, hasDropdown: true },
                            { id: 'oversize-luggage', name: 'Oversize luggage', price: 0, type: 'Amount', quantity: 1 },
                            { id: 'extra-waiting', name: 'Extra waiting time (1 hour)', price: 30, type: 'Amount', quantity: 1 }
                        ]
                    };
                    
                    localStorage.setItem('bookingSurchargeItems', JSON.stringify(defaultSurchargeItems));
                    surchargeItems = defaultSurchargeItems;
                } else {
                    surchargeItems = JSON.parse(bookingSaved);
                }
                
                // Always try to load location surcharges even without admin surcharge items
                loadLocationSurcharges();
            }
            
            console.log('üìÑ Loaded surcharge items:', surchargeItems);
            
            // üÜï Check for automatic Meet & Greet based on pickup location BEFORE rendering
            checkAndApplyMeetAndGreet();
            
            // Render after Meet & Greet check
            renderSurchargeItems();
            // Always show surcharge section immediately
            document.getElementById('surchargeSection').style.display = 'block';
        }

        // Function to check ONLY pickup locations for Meet & Greet (not destinations)
        function checkAndApplyMeetAndGreet() {
            const fromLocation = localStorage.getItem('fromLocation') || '';
            const toLocation = localStorage.getItem('toLocation') || '';
            const hasReturnTrip = localStorage.getItem('returnActive') === 'true';
            
            console.log('ü§ù checkAndApplyMeetAndGreet called:');
            console.log('   - fromLocation:', fromLocation);
            console.log('   - toLocation:', toLocation);
            console.log('   - hasReturnTrip:', hasReturnTrip);
            // Load Meet & Greet locations from admin
            const meetAndGreetLocations = JSON.parse(localStorage.getItem('meetAndGreetLocations') || '{}');
            console.log('ü§ù Available locations:', meetAndGreetLocations);
            
            let meetGreetRequired = false;
            let meetGreetCount = 0;
            let allMeetGreetLocations = [];
            
            // Check pickup location (fromLocation) - ALWAYS check for outbound trips
            if (fromLocation) {
                console.log('ü§ù Checking Meet & Greet for PICKUP location:', fromLocation);
                // Simple Meet & Greet check for common locations
                const pickupCheck = checkSimpleMeetAndGreet(fromLocation);
                
                if (pickupCheck.required) {
                    meetGreetRequired = true;
                    meetGreetCount++;
                    allMeetGreetLocations.push({
                        type: 'pickup',
                        location: pickupCheck.location,
                        instructions: pickupCheck.instructions
                    });
                    console.log('‚úÖ Meet & Greet required for outbound pickup:', pickupCheck.location.name);
                }
            }
            
            // For return trips, check if the return pickup location (= original destination) requires Meet & Greet
            if (hasReturnTrip && toLocation) {
                console.log('ü§ù Checking Meet & Greet for RETURN PICKUP location (return trip):', toLocation);
                const returnPickupCheck = checkSimpleMeetAndGreet(toLocation);
                
                if (returnPickupCheck.required) {
                    meetGreetRequired = true;
                    meetGreetCount++;
                    allMeetGreetLocations.push({
                        type: 'return_pickup',
                        location: returnPickupCheck.location,
                        instructions: returnPickupCheck.instructions
                    });
                    console.log('‚úÖ Meet & Greet required for return pickup:', returnPickupCheck.location.name);
                }
            }
            
            console.log(`üìä Meet & Greet Summary: ${meetGreetCount} locations require service`);
            
            if (meetGreetRequired) {
                // Check if Meet & Greet is enabled in admin settings
                const meetGreetItem = surchargeItems.fixed.find(item => item.id === 'meet-greet');
                const isMeetGreetEnabled = meetGreetItem ? meetGreetItem.enabled : false;
                
                if (isMeetGreetEnabled) {
                    // Auto-enable Meet & Greet surcharge - ALWAYS base price regardless of trip count
                    const basePrice = meetGreetItem ? meetGreetItem.price : 0;
                    const totalPrice = basePrice; // Fixed price per booking, not per location
                    
                    selectedSurcharges['meet-greet'] = {
                        name: `Meet and greet${meetGreetCount > 1 ? ` (${meetGreetCount} locaties)` : ''}`,
                        price: totalPrice,
                        quantity: 1,
                        type: 'fixed',
                        automatic: true, // Automatic = locked (cannot be unchecked)
                        count: meetGreetCount,
                        locations: allMeetGreetLocations
                    };
                    
                    console.log('üí∞ Added Meet & Greet to selectedSurcharges:', selectedSurcharges['meet-greet']);
                    
                    // Save to localStorage
                    localStorage.setItem('selectedSurcharges', JSON.stringify(selectedSurcharges));
                    
                    // üÜï NOTE: Meet & Greet detected - will auto-check checkbox, instructions via email  
                    console.log('‚úÖ Meet & Greet detected and enabled - checkbox will be auto-checked');
                } else {
                    console.log('‚ö†Ô∏è Meet & Greet required but disabled in admin settings - not applying surcharge');
                    
                    // Remove automatic Meet & Greet if previously set
                    if (selectedSurcharges['meet-greet'] && selectedSurcharges['meet-greet'].automatic) {
                        console.log('üóëÔ∏è Removing automatic Meet & Greet (disabled in admin)');
                        delete selectedSurcharges['meet-greet'];
                        localStorage.setItem('selectedSurcharges', JSON.stringify(selectedSurcharges));
                    }
                }
                
            } else {
                console.log('‚ÑπÔ∏è No Meet & Greet required for any location');
                
                // Remove automatic Meet & Greet if previously set
                if (selectedSurcharges['meet-greet'] && selectedSurcharges['meet-greet'].automatic) {
                    console.log('üóëÔ∏è Removing automatic Meet & Greet');
                    delete selectedSurcharges['meet-greet'];
                    localStorage.setItem('selectedSurcharges', JSON.stringify(selectedSurcharges));
                }
            }
        }


        function renderSurchargeItems() {
            renderFixedSurchargeItems();
            renderAdditionalSurchargeItems();
            updateIndividualSurchargePrices();
            updateSurchargeTotal();
            
            // Auto-check boxes for automatically detected surcharges
            setTimeout(() => {
                autoCheckSelectedSurcharges();
            }, 100);
        }

        function autoCheckSelectedSurcharges() {
            // Auto-check checkboxes for items in selectedSurcharges
            for (const itemId in selectedSurcharges) {
                const checkbox = document.getElementById(`surcharge_${itemId}`);
                if (checkbox) {
                    const item = selectedSurcharges[itemId];
                    
                    // Check the checkbox
                    if (!checkbox.checked) {
                        checkbox.checked = true;
                        console.log(`‚úÖ Auto-checked ${itemId} checkbox`);
                    }
                    
                    // If it's automatic (like detected Meet & Greet), disable unchecking
                    if (item.automatic) {
                        checkbox.disabled = true;
                        checkbox.style.opacity = '0.7';
                        console.log(`üîí Locked ${itemId} checkbox (automatic)`);
                    }
                }
            }
        }

        function renderFixedSurchargeItems() {
            const container = document.getElementById('fixedSurchargeItems');
            container.innerHTML = '';

            if (surchargeItems.fixed && surchargeItems.fixed.length > 0) {
                console.log('üìÑ Rendering fixed surcharge items:', surchargeItems.fixed);
                surchargeItems.fixed.forEach(item => {
                    console.log(`üìÑ Rendering fixed item: ${item.name} - ‚Ç¨${item.price} - enabled: ${item.enabled}`);
                    // Show stopover if there are extra stops, but make it read-only
                    if (item.id === 'stopover') {
                        const extraStopCount = parseInt(localStorage.getItem('extraStopCount') || '0');
                        if (extraStopCount > 0) {
                            // Show stopover as automatic charge
                            createStopoverDisplay(item, extraStopCount);
                        }
                        return;
                    }
                    
                    // Handle Meet and greet - only show if actually needed AND enabled
                    if (item.id === 'meet-greet') {
                        console.log('ü§ù Meet & Greet item found - checking if should be shown...');
                        
                        // First check if Meet & Greet is enabled in admin settings
                        if (item.enabled === false) {
                            console.log('‚ùå Meet & Greet DISABLED in admin settings - hiding checkbox completely');
                            return; // Skip rendering this item
                        }
                        
                        // Check if Meet & Greet is required for current locations
                        const fromLocation = localStorage.getItem('fromLocation') || '';
                        const toLocation = localStorage.getItem('toLocation') || '';
                        const hasReturnTrip = localStorage.getItem('returnActive') === 'true';
                        
                        let shouldShow = false;
                        
                        // Check outbound pickup location
                        if (fromLocation) {
                            const pickupCheck = checkSimpleMeetAndGreet(fromLocation);
                            if (pickupCheck.required) {
                                shouldShow = true;
                                console.log('‚úÖ Meet & Greet required for outbound pickup:', fromLocation);
                            }
                        }
                        
                        // Check return pickup location
                        if (hasReturnTrip && toLocation) {
                            const returnPickupCheck = checkSimpleMeetAndGreet(toLocation);
                            if (returnPickupCheck.required) {
                                shouldShow = true;
                                console.log('‚úÖ Meet & Greet required for return pickup:', toLocation);
                            }
                        }
                        
                        if (!shouldShow) {
                            console.log('‚ùå Meet & Greet NOT required - hiding checkbox completely');
                            return; // Skip rendering this item
                        }
                        
                        console.log('‚úÖ Meet & Greet IS required AND enabled - showing checkbox');
                    }
                    
                    // Hide items with ‚Ç¨0.00 price OR disabled items
                    if (item.price === 0 || item.enabled === false) {
                        return;
                    }
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'surcharge-item';
                    
                    // Special handling for items with multiple selection dropdown
                    if (item.hasDropdown && (item.id === 'child-seat' || item.id === 'dog')) {
                        itemDiv.innerHTML = `
                            <div class="surcharge-item-left">
                                <input type="checkbox" id="surcharge_${item.id}" onchange="toggleChildSeatMultiOption('${item.id}', ${item.price}, 'fixed')">
                                <label for="surcharge_${item.id}">${item.name}</label>
                            </div>
                            <div class="surcharge-item-right">
                                <div class="surcharge-price"><!-- Geen prijs hier - individuele prijzen in dropdown --></div>
                            </div>
                        `;
                        
                        // Add multi-selection dropdown using configured options
                        const dropdownDiv = document.createElement('div');
                        dropdownDiv.className = 'child-seat-multi-dropdown';
                        dropdownDiv.id = `childSeatMultiDropdown_${item.id}`;
                        
                        // Get configured options or use defaults based on item type
                        let dropdownOptions;
                        if (item.id === 'child-seat') {
                            dropdownOptions = item.dropdownOptions || [
                                { id: 'maxi_cosi', name: 'Maxi Cosi (baby can\'t sit)', price: 0 },
                                { id: 'baby_seat', name: 'Baby seat', price: 0 },
                                { id: 'verhoostoel', name: 'Verhoostoel', price: 0 }
                            ];
                        } else if (item.id === 'dog') {
                            dropdownOptions = item.dropdownOptions || [
                                { id: 'kleine_hond', name: 'Kleine hond', price: 0 },
                                { id: 'groten_hond', name: 'Groten hond', price: 5 }
                            ];
                        }
                        
                        dropdownDiv.innerHTML = dropdownOptions.map(option => `
                            <div class="child-seat-multi-option">
                                <input type="checkbox" id="${item.id}_${option.id}" onchange="selectMultiVariant('${item.id}', '${option.id}', this.checked, ${option.price})">
                                <label for="${item.id}_${option.id}">${option.name}</label>
                                <div class="child-seat-multi-price">‚Ç¨${option.price.toFixed(2)}</div>
                            </div>
                        `).join('');
                        
                        itemDiv.appendChild(dropdownDiv);
                    } else {
                        // Regular items
                        itemDiv.innerHTML = `
                            <div class="surcharge-item-left">
                                <input type="checkbox" id="surcharge_${item.id}" onchange="toggleSurcharge('${item.id}', ${item.price}, 'fixed')">
                                <label for="surcharge_${item.id}">${item.name}</label>
                            </div>
                            <div class="surcharge-item-right">
                                <div class="surcharge-price">‚Ç¨${item.price.toFixed(2)}</div>
                            </div>
                        `;
                    }
                    
                    container.appendChild(itemDiv);
                });
            }
        }

        function renderAdditionalSurchargeItems() {
            const container = document.getElementById('additionalSurchargeItems');
            container.innerHTML = '';
            
            // First render location-based surcharges
            const savedSurcharges = JSON.parse(localStorage.getItem('selectedSurcharges') || '{}');
            const locationSurcharges = Object.values(savedSurcharges).filter(item => item.isLocationSurcharge);
            
            if (locationSurcharges.length > 0) {
                console.log('üìç Rendering location surcharges:', locationSurcharges);
                locationSurcharges.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'surcharge-item';
                    itemDiv.innerHTML = `
                        <div class="surcharge-item-left">
                            <input type="checkbox" id="surcharge_${item.id}" checked disabled style="opacity: 0.7;">
                            <label for="surcharge_${item.id}">${item.name} (Location)</label>
                        </div>
                        <div class="surcharge-item-right">
                            <div class="surcharge-price">‚Ç¨${item.price.toFixed(2)}</div>
                        </div>
                    `;
                    container.appendChild(itemDiv);
                });
            }

            // Then render regular additional items
            if (surchargeItems.additional && surchargeItems.additional.length > 0) {
                console.log('üìÑ Rendering additional surcharge items:', surchargeItems.additional);
                surchargeItems.additional.forEach(item => {
                    console.log(`üìÑ Rendering additional item: ${item.name} - ‚Ç¨${item.price} - enabled: ${item.enabled}`);
                    // Hide disabled items or items with ‚Ç¨0.00 price
                    if (item.enabled === false || item.price === 0) {
                        return;
                    }
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'surcharge-item';
                    
                    // Special handling for items with dropdown - only show if dropdown options exist
                    if (item.hasDropdown && item.dropdownOptions && item.dropdownOptions.length > 0) {
                        itemDiv.innerHTML = `
                            <div class="surcharge-item-left">
                                <input type="checkbox" id="surcharge_${item.id}" onchange="toggleAdditionalOption('${item.id}', ${item.price}, 'additional')">
                                <label for="surcharge_${item.id}">${item.name}</label>
                            </div>
                            <div class="surcharge-item-right">
                                <div class="surcharge-price"><!-- Geen prijs hier - individuele prijzen in dropdown --></div>
                                <div class="quantity-controls">
                                    <button onclick="adjustSurchargeQuantity('${item.id}', -1)">-</button>
                                    <input type="number" id="quantity_${item.id}" value="1" min="1" max="10" 
                                           onchange="updateSurchargeQuantity('${item.id}', this.value)">
                                    <button onclick="adjustSurchargeQuantity('${item.id}', 1)">+</button>
                                </div>
                            </div>
                        `;
                        
                        // Add dropdown specific to this item
                        const dropdownDiv = document.createElement('div');
                        dropdownDiv.className = 'baby-seat-dropdown';
                        dropdownDiv.id = `additionalDropdown_${item.id}`;
                        
                        // Create different options based on item type
                        let dropdownOptions = '';
                        if (item.id === 'water') {
                            dropdownOptions = `
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_still" name="${item.id}Type" value="still" onchange="selectAdditionalVariant('${item.id}', 'still')">
                                    <label for="${item.id}_still">Still water</label>
                                    <div class="baby-seat-price">‚Ç¨${item.price.toFixed(2)}</div>
                                </div>
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_sparkling" name="${item.id}Type" value="sparkling" onchange="selectAdditionalVariant('${item.id}', 'sparkling')">
                                    <label for="${item.id}_sparkling">Sparkling water</label>
                                    <div class="baby-seat-price">‚Ç¨${(item.price + 1).toFixed(2)}</div>
                                </div>
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_premium" name="${item.id}Type" value="premium" onchange="selectAdditionalVariant('${item.id}', 'premium')">
                                    <label for="${item.id}_premium">Premium water</label>
                                    <div class="baby-seat-price">‚Ç¨${(item.price + 3).toFixed(2)}</div>
                                </div>
                            `;
                        } else if (item.id === 'newspaper') {
                            dropdownOptions = `
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_local" name="${item.id}Type" value="local" onchange="selectAdditionalVariant('${item.id}', 'local')">
                                    <label for="${item.id}_local">Lokale krant</label>
                                    <div class="baby-seat-price">‚Ç¨${item.price.toFixed(2)}</div>
                                </div>
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_national" name="${item.id}Type" value="national" onchange="selectAdditionalVariant('${item.id}', 'national')">
                                    <label for="${item.id}_national">Nationale krant</label>
                                    <div class="baby-seat-price">‚Ç¨${(item.price + 1).toFixed(2)}</div>
                                </div>
                                <div class="baby-seat-option">
                                    <input type="radio" id="${item.id}_international" name="${item.id}Type" value="international" onchange="selectAdditionalVariant('${item.id}', 'international')">
                                    <label for="${item.id}_international">Internationale krant</label>
                                    <div class="baby-seat-price">‚Ç¨${(item.price + 2).toFixed(2)}</div>
                                </div>
                            `;
                        }
                        
                        dropdownDiv.innerHTML = dropdownOptions;
                        itemDiv.appendChild(dropdownDiv);
                    } else {
                        // Regular items without dropdown
                        itemDiv.innerHTML = `
                            <div class="surcharge-item-left">
                                <input type="checkbox" id="surcharge_${item.id}" onchange="toggleSurcharge('${item.id}', ${item.price}, 'additional')">
                                <label for="surcharge_${item.id}">${item.name}</label>
                            </div>
                            <div class="surcharge-item-right">
                                <div class="surcharge-price">‚Ç¨${item.price.toFixed(2)}</div>
                                <div class="quantity-controls">
                                    <button onclick="adjustSurchargeQuantity('${item.id}', -1)">-</button>
                                    <input type="number" id="quantity_${item.id}" value="1" min="1" max="10" 
                                           onchange="updateSurchargeQuantity('${item.id}', this.value)">
                                    <button onclick="adjustSurchargeQuantity('${item.id}', 1)">+</button>
                                </div>
                            </div>
                        `;
                    }
                    
                    container.appendChild(itemDiv);
                });
            }
        }

        function createStopoverDisplay(item, extraStopCount) {
            const container = document.getElementById('fixedSurchargeItems');
            const itemDiv = document.createElement('div');
            itemDiv.className = 'surcharge-item automatic-surcharge';
            itemDiv.style.cssText = 'background: #e3f2fd; border: 2px solid #2196f3; opacity: 0.9;';
            
            let totalStopoverPrice = item.price * extraStopCount;
            let calculationText = `${extraStopCount} √ó ‚Ç¨${item.price.toFixed(2)}`;
            let tripTypeText = extraStopCount === 1 ? 'stop' : 'stops';
            
            // For return trips, double the stopover charges
            if (hasReturnTrip) {
                totalStopoverPrice = totalStopoverPrice * 2;
                calculationText = `${extraStopCount} √ó ‚Ç¨${item.price.toFixed(2)} √ó 2 (heen & terug)`;
                tripTypeText += ' (heen & terug)';
            }
            
            itemDiv.innerHTML = `
                <div class="surcharge-item-left">
                    <input type="checkbox" id="surcharge_${item.id}" checked disabled>
                    <label for="surcharge_${item.id}">${item.name} (${extraStopCount} ${tripTypeText})</label>
                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                        Automatisch berekend: ${calculationText}
                    </div>
                </div>
                <div class="surcharge-item-right">
                    <div class="surcharge-price">‚Ç¨${totalStopoverPrice.toFixed(2)}</div>
                </div>
            `;
            
            container.appendChild(itemDiv);
        }

        function createMeetGreetDisplay(item, meetGreetData) {
            const container = document.getElementById('fixedSurchargeItems');
            const itemDiv = document.createElement('div');
            itemDiv.className = 'surcharge-item automatic-surcharge meet-greet-item';
            itemDiv.style.cssText = 'background: #e8f5e8; border: 2px solid #28a745; opacity: 0.95;';
            
            // Handle both single location and multiple locations
            let displayText = '';
            let totalPrice = 0;
            
            if (meetGreetData.locations && meetGreetData.locations.length > 0) {
                // Multiple locations
                const locationNames = meetGreetData.locations.map(loc => loc.location.name).join(', ');
                displayText = `Automatisch toegevoegd voor ${meetGreetData.locations.length} locaties: ${locationNames}`;
                totalPrice = meetGreetData.price || (item.price * meetGreetData.count);
            } else if (meetGreetData.location) {
                // Single location (backward compatibility)
                displayText = `Automatisch toegevoegd voor ${meetGreetData.location.name}`;
                totalPrice = item.price;
            } else {
                displayText = 'Automatisch toegevoegd';
                totalPrice = item.price;
            }
            
            itemDiv.innerHTML = `
                <div class="surcharge-item-left">
                    <input type="checkbox" id="surcharge_${item.id}" checked disabled>
                    <label for="surcharge_${item.id}">ü§ù ${meetGreetData.name || item.name}</label>
                    <div style="font-size: 12px; color: #155724; margin-top: 4px; font-weight: 500;">
                        ${displayText}
                    </div>
                </div>
                <div class="surcharge-item-right">
                    <div class="surcharge-price">‚Ç¨${totalPrice.toFixed(2)}</div>
                </div>
            `;
            
            container.appendChild(itemDiv);
            
            // The selectedSurcharges should already be set by checkAndApplyMeetAndGreet
            // This function just creates the visual display
        }

        function toggleSurcharge(itemId, price, type) {
            const checkbox = document.getElementById(`surcharge_${itemId}`);
            const quantity = type === 'additional' ? parseInt(document.getElementById(`quantity_${itemId}`).value) : 1;
            
            if (checkbox.checked) {
                selectedSurcharges[itemId] = {
                    name: getSurchargeItemName(itemId),
                    price: price,
                    quantity: quantity,
                    type: type
                };
            } else {
                delete selectedSurcharges[itemId];
            }
            
            updateSurchargeTotal();
        }

        function toggleChildSeatMultiOption(itemId, price, type) {
            const checkbox = document.getElementById(`surcharge_${itemId}`);
            const dropdown = document.getElementById(`childSeatMultiDropdown_${itemId}`);
            
            if (checkbox.checked) {
                // Show dropdown
                dropdown.style.display = 'block';
                dropdown.style.setProperty('display', 'block', 'important');
            } else {
                // Hide dropdown
                dropdown.style.display = 'none';
                dropdown.style.setProperty('display', 'none', 'important');
                
                // Remove all selections (dynamic based on configured options)
                const item = surchargeItems.fixed.find(item => item.id === itemId);
                let defaultOptions = [];
                if (itemId === 'child-seat') {
                    defaultOptions = [{ id: 'maxi_cosi' }, { id: 'baby_seat' }, { id: 'verhoostoel' }];
                } else if (itemId === 'dog') {
                    defaultOptions = [{ id: 'kleine_hond' }, { id: 'groten_hond' }];
                }
                
                const options = item?.dropdownOptions || defaultOptions;
                options.forEach(option => {
                    delete selectedSurcharges[`${itemId}_${option.id}`];
                });
                
                // Clear checkboxes
                dropdown.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                updateSurchargeTotal();
            }
        }
        
        function selectMultiVariant(itemId, variant, isChecked, price) {
            const item = surchargeItems.fixed.find(item => item.id === itemId);
            const variantKey = `${itemId}_${variant}`;
            
            if (item) {
                if (isChecked) {
                    // Find the configured option name and price
                    let defaultOptions = [];
                    if (itemId === 'child-seat') {
                        defaultOptions = [
                            { id: 'maxi_cosi', name: 'Maxi Cosi (baby can\'t sit)', price: 0 },
                            { id: 'baby_seat', name: 'Baby seat', price: 0 },
                            { id: 'verhoostoel', name: 'Verhoostoel', price: 0 }
                        ];
                    } else if (itemId === 'dog') {
                        defaultOptions = [
                            { id: 'kleine_hond', name: 'Kleine hond', price: 0 },
                            { id: 'groten_hond', name: 'Groten hond', price: 5 }
                        ];
                    }
                    
                    const options = item.dropdownOptions || defaultOptions;
                    const option = options.find(opt => opt.id === variant);
                    
                    selectedSurcharges[variantKey] = {
                        name: option ? option.name : variant,
                        price: price || (option ? option.price : 3),
                        quantity: 1,
                        type: 'fixed',
                        variant: variant
                    };
                } else {
                    delete selectedSurcharges[variantKey];
                }
                
                updateSurchargeTotal();
            }
        }

        // Function removed - no longer needed as child seats are now individual items
        
        function checkForSurchargeUpdates() {
            const adminSurchargeData = localStorage.getItem('surchargeItems');
            const adminUpdateTime = localStorage.getItem('surchargeItemsUpdateTime');
            
            if (adminSurchargeData && adminUpdateTime) {
                const updateTime = parseInt(adminUpdateTime);
                
                // Check if admin data has been updated since last check
                if (updateTime > lastSurchargeUpdateTime) {
                    console.log('üîÑ Admin surcharge data updated, refreshing...');
                    lastSurchargeUpdateTime = updateTime;
                    
                    // Update surcharge items from admin
                    surchargeItems = JSON.parse(adminSurchargeData);
                    localStorage.setItem('bookingSurchargeItems', JSON.stringify(surchargeItems));
                    
                    // Re-render surcharge items
                    renderSurchargeItems();
                    
                    // Show update notification
                    showUpdateNotification('Item Surcharge opties zijn bijgewerkt vanuit Admin');
                }
            }
        }
        
        function showUpdateNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                z-index: 1000;
                font-size: 14px;
                font-weight: 600;
                max-width: 300px;
                animation: slideIn 0.3s ease-out;
            `;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span>üîÑ</span>
                    <span>${message}</span>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }

        function toggleAdditionalOption(itemId, price, type) {
            const checkbox = document.getElementById(`surcharge_${itemId}`);
            const dropdown = document.getElementById(`additionalDropdown_${itemId}`);
            
            if (checkbox.checked) {
                // Show dropdown
                dropdown.style.display = 'block';
                
                // Select first option by default
                const firstOption = dropdown.querySelector('input[type="radio"]');
                if (firstOption) {
                    firstOption.checked = true;
                    selectAdditionalVariant(itemId, firstOption.value);
                }
            } else {
                // Hide dropdown
                dropdown.style.display = 'none';
                
                // Remove selection
                delete selectedSurcharges[itemId];
                
                // Clear radio buttons
                dropdown.querySelectorAll('input[type="radio"]').forEach(radio => {
                    radio.checked = false;
                });
                
                updateSurchargeTotal();
            }
        }

        function selectAdditionalVariant(itemId, variant) {
            const additionalItem = surchargeItems.additional.find(item => item.id === itemId);
            
            if (additionalItem) {
                let price = additionalItem.price;
                let variantName = '';
                const quantity = parseInt(document.getElementById(`quantity_${itemId}`).value) || 1;
                
                // Different pricing and naming based on item and variant
                if (itemId === 'water') {
                    switch(variant) {
                        case 'still':
                            price = additionalItem.price;
                            variantName = 'Still water';
                            break;
                        case 'sparkling':
                            price = additionalItem.price + 1;
                            variantName = 'Sparkling water';
                            break;
                        case 'premium':
                            price = additionalItem.price + 3;
                            variantName = 'Premium water';
                            break;
                    }
                } else if (itemId === 'newspaper') {
                    switch(variant) {
                        case 'local':
                            price = additionalItem.price;
                            variantName = 'Lokale krant';
                            break;
                        case 'national':
                            price = additionalItem.price + 1;
                            variantName = 'Nationale krant';
                            break;
                        case 'international':
                            price = additionalItem.price + 2;
                            variantName = 'Internationale krant';
                            break;
                    }
                }
                
                selectedSurcharges[itemId] = {
                    name: variantName,
                    price: price,
                    quantity: quantity,
                    type: 'additional',
                    variant: variant
                };
                
                updateSurchargeTotal();
            }
        }

        function getSurchargeItemName(itemId) {
            const fixedItem = surchargeItems.fixed.find(item => item.id === itemId);
            if (fixedItem) return fixedItem.name;
            
            const additionalItem = surchargeItems.additional.find(item => item.id === itemId);
            if (additionalItem) return additionalItem.name;
            
            return 'Unknown Item';
        }

        function adjustSurchargeQuantity(itemId, delta) {
            const quantityInput = document.getElementById(`quantity_${itemId}`);
            const currentQuantity = parseInt(quantityInput.value);
            const newQuantity = Math.max(1, Math.min(10, currentQuantity + delta));
            quantityInput.value = newQuantity;
            updateSurchargeQuantity(itemId, newQuantity);
        }

        function updateSurchargeQuantity(itemId, quantity) {
            if (selectedSurcharges[itemId]) {
                selectedSurcharges[itemId].quantity = parseInt(quantity);
                updateSurchargeTotal();
            }
        }

        function updateSurchargeTotal() {
            console.log('üîÑ SURCHARGE DEBUG: Starting calculation...');
            surchargeTotal = 0;
            
            // Add selected surcharges with return trip logic
            for (const itemId in selectedSurcharges) {
                const item = selectedSurcharges[itemId];
                const itemPrice = parseFloat(item.price) || 0;
                const itemQuantity = parseInt(item.quantity) || 1;
                let itemTotal = itemPrice * itemQuantity;
                
                // üÜï FIXED: Double physical items for return trips, but NOT Meet & Greet
                if (hasReturnTrip) {
                    // Items that should be doubled for heen + terug
                    const doubleForReturnItems = [
                        'child-seat', 'booster-seat', 'infant-seat', // All child seats
                        'dog', // Dog travels both directions
                        'golf-material', 'ski-material', // Equipment travels both directions
                        'extra-waiting-time' // May be needed for both pickup and return
                    ];
                    
                    // Check if itemId matches directly OR starts with any doubleForReturnItems (for dropdown variants)
                    const shouldDouble = doubleForReturnItems.includes(itemId) || 
                                       doubleForReturnItems.some(baseItem => itemId.startsWith(baseItem + '_'));
                    
                    if (shouldDouble) {
                        itemTotal = itemTotal * 2;
                        console.log(`üí∞ Adding surcharge (DOUBLED): "${item.name}" [ID: ${itemId}] = ‚Ç¨${itemPrice} √ó ${itemQuantity} √ó 2 = ‚Ç¨${itemTotal.toFixed(2)}`);
                    } else {
                        console.log(`üí∞ Adding surcharge (single): "${item.name}" [ID: ${itemId}] = ‚Ç¨${itemPrice} √ó ${itemQuantity} = ‚Ç¨${itemTotal.toFixed(2)}`);
                    }
                } else {
                    console.log(`üí∞ Adding surcharge: "${item.name}" [ID: ${itemId}] = ‚Ç¨${itemPrice} √ó ${itemQuantity} = ‚Ç¨${itemTotal.toFixed(2)}`);
                }
                
                surchargeTotal += itemTotal;
            }
            
            // Automatically add stopover charges based on extra stops from STAP 1
            const extraStopCount = parseInt(localStorage.getItem('extraStopCount') || '0');
            if (extraStopCount > 0) {
                const stopoverItem = surchargeItems.fixed.find(item => item.id === 'stopover');
                if (stopoverItem) {
                    let stopoverTotal = (parseFloat(stopoverItem.price) || 0) * extraStopCount;
                    
                    // Voor heen en terug: verdubbel stopover charges (stops voor beide richtingen)
                    if (hasReturnTrip) {
                        stopoverTotal = stopoverTotal * 2;
                        console.log(`üìç Stopover charges: ${extraStopCount} stops √ó ‚Ç¨${stopoverItem.price} √ó 2 (heen & terug) = ‚Ç¨${stopoverTotal}`);
                    } else {
                        console.log(`üìç Stopover charges: ${extraStopCount} stops √ó ‚Ç¨${stopoverItem.price} = ‚Ç¨${stopoverTotal}`);
                    }
                    
                    surchargeTotal += stopoverTotal;
                }
            }
            
            console.log(`üîç SURCHARGE BREAKDOWN:`);
            console.log(`   Selected surcharges total: ‚Ç¨${surchargeTotal - ((extraStopCount > 0 && hasReturnTrip) ? (parseFloat(surchargeItems.fixed.find(item => item.id === 'stopover')?.price || 10) * extraStopCount * 2) : (parseFloat(surchargeItems.fixed.find(item => item.id === 'stopover')?.price || 10) * extraStopCount))}`);
            console.log(`   Extra stops (${extraStopCount}): ‚Ç¨${(extraStopCount > 0 && hasReturnTrip) ? (parseFloat(surchargeItems.fixed.find(item => item.id === 'stopover')?.price || 10) * extraStopCount * 2) : (parseFloat(surchargeItems.fixed.find(item => item.id === 'stopover')?.price || 10) * extraStopCount)}`);
            console.log(`   TOTAL surcharges: ‚Ç¨${surchargeTotal.toFixed(2)}`);
            document.getElementById('surchargeTotalAmount').textContent = `‚Ç¨${surchargeTotal.toFixed(2)}`;
            
            // üö® CRITICAL FIX: SAVE SURCHARGE DATA TO LOCALSTORAGE
            const surchargeDataToSave = {
                ...selectedSurcharges,
                totalSurcharge: surchargeTotal
            };
            
            console.log('üíæ SAVING SURCHARGE DATA TO LOCALSTORAGE:', surchargeDataToSave);
            localStorage.setItem('selectedSurcharges', JSON.stringify(surchargeDataToSave));
            
            // Update main price display if vehicle is selected
            if (selectedVehicleOutbound) {
                updateTotalPrice();
            }
        }

        function updateTotalPrice() {
            if (!selectedVehicleOutbound) {
                console.log('‚ö†Ô∏è updateTotalPrice: No selectedVehicleOutbound');
                return;
            }
            
            console.log('üîç DEBUG updateTotalPrice:', {
                selectedVehicleOutbound: selectedVehicleOutbound,
                pricing: selectedVehicleOutbound.pricing,
                minimumPrice: selectedVehicleOutbound.pricing.minimumPrice,
                typeof: typeof selectedVehicleOutbound.pricing.minimumPrice
            });
            
            // üÜï SAFETY CHECK: Ensure we use the latest admin pricing data
            const vehicleId = selectedVehicleOutbound.vehicle.id;
            const latestBasePricing = pricingData[vehicleId];
            
            if (latestBasePricing) {
                // Recalculate pricing with latest admin data
                const latestPricing = calculateDistanceBasedPricing(latestBasePricing);
                
                // Only update if pricing actually changed
                if (JSON.stringify(selectedVehicleOutbound.pricing) !== JSON.stringify(latestPricing)) {
                    console.log(`üîÑ Updating selected vehicle pricing with latest admin data:`, latestPricing);
                    selectedVehicleOutbound.pricing = latestPricing;
                }
            }
            
            // Get base price from selected vehicle - ensure it's a number
            let basePrice = parseFloat(selectedVehicleOutbound.pricing.minimumPrice) || 0;
            
            // For return trips, double the base price
            if (hasReturnTrip) {
                basePrice = basePrice * 2;
                console.log(`üîÑ Return trip detected: doubling base price to ‚Ç¨${basePrice}`);
            }
            
            // Ensure surchargeTotal is a number
            const surcharges = isNaN(surchargeTotal) ? 0 : surchargeTotal;
            
            console.log(`üîç SURCHARGE DEBUG in updateTotalPrice:`);
            console.log(`   surchargeTotal variable: ‚Ç¨${surchargeTotal}`);
            console.log(`   selectedSurcharges object:`, selectedSurcharges);
            console.log(`   extraStopCount: ${localStorage.getItem('extraStopCount')}`);
            console.log(`   hasReturnTrip: ${hasReturnTrip}`);
            
            let calculatedTotal = basePrice + surcharges;
            
            // Apply last-minute surcharge if applicable
            const travelDate = localStorage.getItem('travelDate');
            const travelHour = localStorage.getItem('travelHour');
            const travelMinute = localStorage.getItem('travelMinute');
            
            if (travelDate && travelHour && travelMinute) {
                const lastMinuteCheck = isLastMinuteBooking(travelDate, travelHour, travelMinute);
                console.log('‚ö° LAST-MINUTE CHECK RESULT:', lastMinuteCheck);
                
                if (lastMinuteCheck.isLastMinute) {
                    // Calculate surcharge on BASE price (before doubling for return), then apply to return total
                    const basePriceForSurcharge = parseFloat(selectedVehicleOutbound.pricing.minimumPrice);
                    const lastMinuteSurcharge = calculateLastMinuteSurcharge(basePriceForSurcharge);
                    
                    // For return trips, apply surcharge to BOTH legs
                    const totalSurcharge = hasReturnTrip ? (lastMinuteSurcharge * 2) : lastMinuteSurcharge;
                    calculatedTotal += totalSurcharge;
                    
                    console.log(`üî• MARCEL FIX: Base price ‚Ç¨${basePriceForSurcharge}, surcharge per trip ‚Ç¨${lastMinuteSurcharge.toFixed(2)}`);
                    console.log(`üî• Return trip: ${hasReturnTrip}, total surcharge: ‚Ç¨${totalSurcharge.toFixed(2)}, final total: ‚Ç¨${calculatedTotal.toFixed(2)}`);
                    
                    // Show last-minute warning banner
                    showLastMinuteSurchargeWarning(lastMinuteCheck.settings);
                } else {
                    console.log('‚úÖ No last-minute surcharge needed - normal timing');
                }
            } else {
                console.log('‚ö†Ô∏è No travel time data found for last-minute check');
            }
            
            // Round up the final total price
            const finalTotalPrice = Math.ceil(calculatedTotal);
            
            console.log(`üí∞ Total Price Update: Base ‚Ç¨${basePrice}${hasReturnTrip ? ' (heen & terug)' : ''} + Surcharges ‚Ç¨${surcharges} = ‚Ç¨${calculatedTotal.toFixed(2)} ‚Üí ‚Ç¨${finalTotalPrice}`);
            
            // üÜï SAVE THE FINAL TOTAL PRICE TO LOCALSTORAGE FOR STEP 3
            localStorage.setItem('step2FinalTotalPrice', finalTotalPrice.toString());
            console.log(`üíæ Saved final total price to localStorage: ‚Ç¨${finalTotalPrice}`);
            
            // Update the selected price display
            const priceElement = document.getElementById('selectedMinPrice');
            if (priceElement) {
                priceElement.textContent = `‚Ç¨${finalTotalPrice}`;
                console.log(`‚úÖ Price display updated: ‚Ç¨${finalTotalPrice}`);
            } else {
                console.error('‚ùå Element selectedMinPrice not found!');
            }
        }

        // Load surcharge items when vehicle is selected
        function showSurchargeSection() {
            console.log('üöó Vehicle selected, showing surcharge section');
            loadSurchargeItems();
            document.getElementById('surchargeSection').style.display = 'block';
        }

        // Debug function
        function debugSurchargeSection() {
            console.log('üîç DEBUG: Surcharge section status:');
            console.log('- Section element:', document.getElementById('surchargeSection'));
            console.log('- Section display:', document.getElementById('surchargeSection')?.style.display);
            console.log('- Fixed items container:', document.getElementById('fixedSurchargeItems'));
            console.log('- Additional items container:', document.getElementById('additionalSurchargeItems'));
            console.log('- localStorage bookingSurchargeItems:', localStorage.getItem('bookingSurchargeItems'));
            console.log('- surchargeItems variable:', surchargeItems);
        }

        // üìç LOCATION SURCHARGE INTEGRATION
        let activeLocationSurcharges = [];

        function loadLocationSurcharges() {
            console.log('üìç Loading Location Surcharges from admin...');
            
            const saved = localStorage.getItem('bookingSystemLocationSurcharges');
            if (saved) {
                activeLocationSurcharges = JSON.parse(saved);
                console.log('‚úÖ Loaded Location Surcharges:', activeLocationSurcharges);
                
                // Apply location surcharges automatically
                applyLocationSurcharges();
            } else {
                console.log('‚ÑπÔ∏è No active Location Surcharges found');
            }
        }

        function applyLocationSurcharges() {
            const fromLocation = localStorage.getItem('fromLocation') || '';
            const toLocation = localStorage.getItem('toLocation') || '';
            
            console.log('üìç Checking location surcharges for:', { fromLocation, toLocation });
            
            let applicableSurcharges = [];
            
            activeLocationSurcharges.forEach(surcharge => {
                if (surcharge.active && surcharge.addresses && surcharge.addresses.length > 0) {
                    let isApplicable = false;
                    const direction = surcharge.locationDirection || 'any';
                    
                    surcharge.addresses.forEach(addr => {
                        // Check if address/postcode matches based on direction
                        let matchesFrom = false;
                        let matchesTo = false;
                        
                        // Check if address matches
                        if (addr.address) {
                            if (fromLocation.toLowerCase().includes(addr.address.toLowerCase())) {
                                matchesFrom = true;
                            }
                            if (toLocation.toLowerCase().includes(addr.address.toLowerCase())) {
                                matchesTo = true;
                            }
                        }
                        
                        // Check if postcode matches
                        if (addr.postcode) {
                            if (fromLocation.includes(addr.postcode)) {
                                matchesFrom = true;
                            }
                            if (toLocation.includes(addr.postcode)) {
                                matchesTo = true;
                            }
                        }
                        
                        // Apply based on direction setting
                        if (direction === 'any' && (matchesFrom || matchesTo)) {
                            isApplicable = true;
                        } else if (direction === 'pickup' && matchesFrom) {
                            isApplicable = true;
                        } else if (direction === 'dropoff' && matchesTo) {
                            isApplicable = true;
                        }
                    });
                    
                    if (isApplicable) {
                        applicableSurcharges.push({
                            id: surcharge.id,
                            name: surcharge.name,
                            price: surcharge.price,
                            enabled: true,
                            quantity: 1,
                            isLocationSurcharge: true
                        });
                        console.log(`‚úÖ Applied location surcharge: ${surcharge.name} (‚Ç¨${surcharge.price}) - Direction: ${direction}`);
                    }
                }
            });
            
            if (applicableSurcharges.length > 0) {
                // Add to selected surcharges
                let selectedSurcharges = JSON.parse(localStorage.getItem('selectedSurcharges') || '{}');
                
                applicableSurcharges.forEach(surcharge => {
                    selectedSurcharges[surcharge.id] = surcharge;
                });
                
                localStorage.setItem('selectedSurcharges', JSON.stringify(selectedSurcharges));
                console.log('üíæ Saved location surcharges to selectedSurcharges');
                
                // Refresh the surcharge display if it exists
                setTimeout(() => {
                    if (typeof renderItemSurcharges === 'function') {
                        renderItemSurcharges();
                    }
                }, 500);
            }
        }

        // Listen for localStorage changes (from admin panel - between tabs)
        window.addEventListener('storage', function(e) {
            console.log('üîÑ localStorage changed:', e.key);
            
            // Refresh location surcharges if they changed
            if (e.key === 'bookingSystemLocationSurcharges') {
                console.log('üîÑ Location surcharges updated, reloading...');
                loadLocationSurcharges();
            }
            
            // ONLY refresh vehicles if vehicle/pricing data changed - NOT for last-minute settings
            if (e.key === 'taxiVehicles' || e.key === 'vehiclePricing') {
                console.log('‚ö° Vehicle/pricing data changed, refreshing vehicles...');
                setTimeout(() => {
                    renderVehicles();
                }, 300);
            }
            
            // Only refresh surcharges and last-minute for those specific changes
            if (e.key === 'defaultLastMinuteSettings' || e.key === 'surchargeItems') {
                console.log('‚ö° Surcharge settings changed, refreshing prices only...');
                setTimeout(() => {
                    loadSurchargeItems();
                    checkLastMinuteBooking();
                    updateSurchargeTotal();
                    // Update prices without clearing vehicle cards
                    updateVehiclePricesOnly();
                }, 300);
            }
        });

        // Polling system to detect changes within same window/tab
        let lastSettingsCheck = '';
        let lastVehicleCheck = '';
        let lastSurchargeCheck = '';
        
        function checkForAdminChanges() {
            const currentSettings = localStorage.getItem('defaultLastMinuteSettings') || '';
            const currentVehicles = localStorage.getItem('taxiVehicles') || '';
            const currentSurcharges = localStorage.getItem('surchargeItems') || '';
            
            let hasChanges = false;
            
            if (currentSettings !== lastSettingsCheck) {
                console.log('‚ö° Last-minute settings changed, refreshing...');
                lastSettingsCheck = currentSettings;
                hasChanges = true;
            }
            
            if (currentVehicles !== lastVehicleCheck) {
                console.log('‚ö° Vehicle settings changed, refreshing...');
                lastVehicleCheck = currentVehicles;
                hasChanges = true;
            }
            
            if (currentSurcharges !== lastSurchargeCheck) {
                console.log('‚ö° Surcharge settings changed, refreshing...');
                lastSurchargeCheck = currentSurcharges;
                hasChanges = true;
            }
            
            if (hasChanges) {
                // Re-render everything
                renderVehicles();
                loadSurchargeItems();
                checkLastMinuteBooking();
                updateSurchargeTotal();
            }
        }
        
        // Check for changes every 2 seconds
        setInterval(checkForAdminChanges, 2000);

        // Initialize page when loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üìÑ Step 2 page loaded, initializing...');
            
            // Debug localStorage data
            console.log('üîç DEBUG localStorage data:');
            console.log('   - fromLocation:', localStorage.getItem('fromLocation'));
            console.log('   - toLocation:', localStorage.getItem('toLocation'));
            console.log('   - returnActive:', localStorage.getItem('returnActive'));
            console.log('   - travelDate:', localStorage.getItem('travelDate'));
            console.log('   - travelHour:', localStorage.getItem('travelHour'));
            console.log('   - travelMinute:', localStorage.getItem('travelMinute'));
            console.log('   - defaultLastMinuteSettings:', localStorage.getItem('defaultLastMinuteSettings'));
            console.log('   - meetAndGreetLocations:', localStorage.getItem('meetAndGreetLocations'));
            console.log('   - surchargeItems:', localStorage.getItem('surchargeItems'));
            
            // Load surcharge items immediately on page load
            setTimeout(() => {
                console.log('üîÑ Auto-loading surcharge items...');
                loadSurchargeItems();
                
                // Force Meet & Greet check after a delay
                setTimeout(() => {
                    console.log('üîÑ Force checking Meet & Greet...');
                    checkAndApplyMeetAndGreet();
                    
                    // Force check last-minute booking status
                    console.log('‚ö° Force checking last-minute booking status...');
                    checkLastMinuteBooking();
                    
                    updateSurchargeTotal();
                }, 1000);
                
                // Call debug function
                setTimeout(debugSurchargeSection, 2000);
                
                // Initialize change detection values
                lastSettingsCheck = localStorage.getItem('defaultLastMinuteSettings') || '';
                lastVehicleCheck = localStorage.getItem('taxiVehicles') || '';
                lastSurchargeCheck = localStorage.getItem('surchargeItems') || '';
            }, 500);
        });

        // Also call debug function after page load (backup)
        setTimeout(debugSurchargeSection, 2000);

        
        function showLastMinuteSurchargeWarning(settings) {
            console.log('‚ö° Showing last-minute surcharge warning');
            
            // Create warning banner
            const banner = document.createElement('div');
            banner.style.cssText = `
                background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
                border: 2px solid #f39c12;
                border-radius: 10px;
                padding: 20px;
                margin: 20px;
                text-align: center;
                box-shadow: 0 5px 15px rgba(243, 156, 18, 0.2);
            `;
            
            let surchargeText = '';
            if (settings.type === 'percentage') {
                surchargeText = `${settings.amount}% extra toeslag`;
            } else {
                surchargeText = `‚Ç¨${settings.amount} extra toeslag`;
            }
            
            // Last-minute banner hidden from user - but surcharge still applies
            banner.style.display = 'none';
            
            // Insert banner after step header (but hidden)
            const stepHeader = document.querySelector('.step-header');
            if (stepHeader) {
                stepHeader.insertAdjacentElement('afterend', banner);
            }
        }
        
        // Admin panel functions (copied from admin-drivers.html)
        function isLastMinuteBooking(travelDate, travelHour, travelMinute) {
            // Get travel data from localStorage if not provided as parameters
            if (!travelDate) {
                travelDate = localStorage.getItem('travelDate');
            }
            if (!travelHour) {
                travelHour = localStorage.getItem('travelHour');
            }
            if (!travelMinute) {
                travelMinute = localStorage.getItem('travelMinute');
            }
            
            // Safety check: if no travel data available, not a last-minute booking
            if (!travelDate || !travelHour || !travelMinute) {
                console.log('‚ö° No travel data available - not a last minute booking');
                return { isLastMinute: false, mode: 'no-travel-data', hoursUntilTravel: null, settings: {} };
            }
            
            // First try to load from defaultLastMinuteSettings (admin configured)
            let settings = JSON.parse(localStorage.getItem('defaultLastMinuteSettings') || '{}');
            console.log('‚ö° LOADING defaultLastMinuteSettings:', settings);
            
            // Check if we have valid default settings, if not use SAFE ZERO defaults
            if (!settings.type) {
                console.log('‚ùå No admin settings found, using SAFE ZERO defaults');
                settings = {
                    type: 'percentage',
                    amount: 0,
                    hours: 0,
                    enabled: false
                };
                // Save the safe fallback settings for future use
                localStorage.setItem('defaultLastMinuteSettings', JSON.stringify(settings));
                console.log('üíæ SAFE ZERO last-minute settings saved:', settings);
            }
            
            // Respect admin's 0% or 0 hours settings - do NOT override!
            if (settings.amount === 0 || settings.amount === '0') {
                console.log('‚ö° Admin set 0% - NO surcharge will be applied');
                settings.enabled = false;
            }
            if (settings.hours === 0 || settings.hours === '0') {
                console.log('‚ö° Admin set 0 hours - NO surcharge will be applied');
                settings.enabled = false;
            }
            
            // Enable surcharge mode ONLY if admin set BOTH percentage > 0 AND hours > 0
            if (settings.amount > 0 && settings.hours > 0) {
                settings.enabled = true;
                settings.mode = 'surcharge';
                console.log('‚úÖ Surcharge mode ENABLED - ' + settings.amount + '% within ' + settings.hours + ' hours');
            } else {
                settings.enabled = false;
                settings.mode = 'disabled';
                if (settings.amount === 0) {
                    console.log('‚ö° Surcharge mode DISABLED - admin set 0% amount');
                } else if (settings.hours === 0) {
                    console.log('‚ö° Surcharge mode DISABLED - admin set 0 hours');
                } else {
                    console.log('‚ö° Surcharge mode DISABLED - admin settings invalid');
                }
            }
            
            console.log('‚ö° Using last-minute settings:', settings);
            
            const now = new Date();
            const bookingTime = new Date();
            
            // Parse travel date (DD/MM/YYYY format)
            const dateParts = travelDate.split('/');
            if (dateParts.length !== 3) {
                return { isLastMinute: false, mode: null };
            }
            
            bookingTime.setDate(parseInt(dateParts[0]));
            bookingTime.setMonth(parseInt(dateParts[1]) - 1); // Month is 0-indexed
            bookingTime.setFullYear(parseInt(dateParts[2]));
            bookingTime.setHours(parseInt(travelHour));
            bookingTime.setMinutes(parseInt(travelMinute));
            bookingTime.setSeconds(0);
            
            const hoursUntilTravel = (bookingTime - now) / (1000 * 60 * 60);
            // MARCEL'S RULE: If 0% or 0 hours, NEVER last minute
            if (settings.amount == 0 || settings.hours == 0) {
                console.log('üî• MARCEL: 0% or 0 hours - NEVER last minute!');
                return { isLastMinute: false, mode: 'marcel-disabled', hoursUntilTravel: hoursUntilTravel, settings: settings };
            }
            
            // FIXED: Only apply surcharge if admin enabled it AND within time limit
            const isLastMinute = settings.enabled && (hoursUntilTravel <= settings.hours);
            
            console.log('‚ö° Last-minute booking check:', {
                now: now.toISOString(),
                travelTime: bookingTime.toISOString(),
                hoursUntilTravel: hoursUntilTravel.toFixed(2),
                surchargeHours: settings.hours,
                isLastMinute: isLastMinute,
                mode: settings.mode
            });
            
            return { 
                isLastMinute: isLastMinute, 
                mode: settings.mode,
                hoursUntilTravel: hoursUntilTravel,
                settings: settings 
            };
        }
        
        function calculateLastMinuteSurcharge(basePrice) {
            // MARCEL'S SIMPLE FUNCTION - NOTHING ELSE MATTERS
            console.log('üî• MARCEL SIMPLE RULE: Starting surcharge check...');
            
            let settings = JSON.parse(localStorage.getItem('defaultLastMinuteSettings') || '{}');
            console.log('üî• Settings loaded:', settings);
            
            // MARCEL'S RULE: Only NO surcharge if 0% OR 0 hours
            if (settings.amount == 0 || settings.hours == 0) {
                console.log('üî• MARCEL: 0% OR 0 hours = RETURN 0');
                return 0;
            }
            
            // If we get here, both amount > 0 AND hours > 0, so calculate surcharge
            console.log('üî• MARCEL: Non-zero values - calculating surcharge');
            let surcharge = 0;
            
            if (settings.type === 'percentage' && settings.amount > 0) {
                surcharge = (basePrice * settings.amount) / 100;
                console.log(`üî• MARCEL: ${settings.amount}% of ‚Ç¨${basePrice} = ‚Ç¨${surcharge.toFixed(2)}`);
            }
            
            return surcharge;
            
            // üõ°Ô∏è SMART CHECK: Only apply surcharge if admin explicitly wants it
            console.log('üîç SMART CHECK:', {
                hasAmount: settings.hasOwnProperty('amount'),
                amount: settings.amount,
                hasHours: settings.hasOwnProperty('hours'), 
                hours: settings.hours,
                hasEnabled: settings.hasOwnProperty('enabled'),
                enabled: settings.enabled
            });
            
            // If amount is 0, return 0 (no surcharge)
            if (settings.amount === 0 || settings.amount === '0') {
                console.log('‚ö° Amount is 0% - NO surcharge applied');
                return 0;
            }
            
            // If hours is 0, return 0 (no bookings within 0 hours)
            if (settings.hours === 0 || settings.hours === '0') {
                console.log('‚ö° Hours is 0 - NO surcharge applied');
                return 0;
            }
            
            // If explicitly disabled, return 0
            if (settings.enabled === false) {
                console.log('‚ö° Feature is disabled - NO surcharge applied');
                return 0;
            }
            
            // Check if we have valid settings, if not use defaults
            if (!settings.type || !settings.hasOwnProperty('amount') || !settings.hasOwnProperty('hours')) {
                console.log('‚ùå Missing admin settings, using defaults');
                settings = {
                    type: settings.type || 'percentage',
                    amount: settings.hasOwnProperty('amount') ? settings.amount : 0, // Default to 0 if not set
                    hours: settings.hasOwnProperty('hours') ? settings.hours : 0,   // Default to 0 if not set
                    enabled: settings.hasOwnProperty('enabled') ? settings.enabled : false // Default disabled
                };
                localStorage.setItem('defaultLastMinuteSettings', JSON.stringify(settings));
                console.log('üíæ Default settings saved:', settings);
                
                // After setting defaults, check again
                if (settings.amount === 0 || settings.hours === 0 || settings.enabled === false) {
                    console.log('‚ö° Default settings prevent surcharge - returning 0');  
                    return 0;
                }
            }
            
            // FINAL CHECK: Verify the booking is actually last-minute before calculating
            const lastMinuteCheck = isLastMinuteBooking();
            if (!lastMinuteCheck.isLastMinute) {
                console.log('‚ö° NOT a last-minute booking - NO surcharge applied');
                return 0;
            }
            
            // surcharge variable already declared above - don't redeclare
            
            if (settings.type === 'percentage') {
                surcharge = (basePrice * settings.amount) / 100;
            } else {
                surcharge = parseFloat(settings.amount) || 0;
            }
            
            console.log('‚ö° Last-minute surcharge calculation:', {
                basePrice: basePrice,
                type: settings.type,
                amount: settings.amount,
                surcharge: surcharge
            });
            
            return surcharge;
        }
        
        // üö® OLD FUNCTION DISABLED - BACKUP
        function calculateLastMinuteSurcharge_OLD_DISABLED(basePrice) {
            // Load from defaultLastMinuteSettings (admin configured)
            let settings = JSON.parse(localStorage.getItem('defaultLastMinuteSettings') || '{}');
            console.log('‚ö° CALCULATING surcharge with settings:', settings);
            
            // Check if we have valid settings, if not use fallback defaults
            if (!settings.type || !settings.amount) {
                console.log('‚ùå No valid surcharge settings found, using fallback defaults');
                settings = {
                    type: 'percentage',
                    amount: 25,
                    hours: 3
                };
                // Save the fallback settings for future use
                localStorage.setItem('defaultLastMinuteSettings', JSON.stringify(settings));
                console.log('üíæ Fallback surcharge settings saved:', settings);
            }
            
            let surcharge = 0;
            
            if (settings.type === 'percentage') {
                surcharge = (basePrice * settings.amount) / 100;
            } else {
                surcharge = parseFloat(settings.amount) || 0;
            }
            
            console.log('‚ö° Last-minute surcharge calculation:', {
                basePrice: basePrice,
                type: settings.type,
                amount: settings.amount,
                surcharge: surcharge
            });
            
            return surcharge;
        }
        
        // Check last-minute booking on page load
        function checkLastMinuteBooking() {
            const travelDate = localStorage.getItem('travelDate');
            const travelHour = localStorage.getItem('travelHour');
            const travelMinute = localStorage.getItem('travelMinute');
            
            console.log('‚ö° CHECKING last-minute booking:', { travelDate, travelHour, travelMinute });
            
            if (!travelDate || !travelHour || !travelMinute) {
                console.log('‚ö†Ô∏è No travel data found - cannot check last-minute booking');
                return;
            }
            
            const lastMinuteCheck = isLastMinuteBooking(travelDate, travelHour, travelMinute);
            console.log('‚ö° Last-minute check result:', lastMinuteCheck);
            
            if (lastMinuteCheck.isLastMinute) {
                console.log('‚ö° LAST-MINUTE BOOKING DETECTED! Showing warning...');
                showLastMinuteSurchargeWarning(lastMinuteCheck.settings);
                
                // Force re-render vehicles with surcharge prices
                console.log('üîÑ Re-rendering vehicles with last-minute surcharges...');
                setTimeout(() => {
                    renderVehicles();
                }, 500);
            } else {
                console.log('‚úÖ Normal booking timing - no surcharge needed');
            }
        }

        // Make test functions globally available
        window.testMeetAndGreet = testMeetAndGreet;
        window.testMeetAndGreetReturn = testMeetAndGreetReturn;
        window.testGoingToAirport = testGoingToAirport;
        window.checkLastMinuteBooking = checkLastMinuteBooking;
        
        // Test function for last-minute pricing
        window.testLastMinutePricing = function() {
            console.log('üß™ TESTING last-minute pricing...');
            
            // Set test travel time (2 hours from now)
            const now = new Date();
            const travelTime = new Date(now.getTime() + 2 * 60 * 60 * 1000); // +2 hours
            
            const dateStr = `${travelTime.getDate().toString().padStart(2, '0')}/${(travelTime.getMonth() + 1).toString().padStart(2, '0')}/${travelTime.getFullYear()}`;
            const hour = travelTime.getHours().toString();
            const minute = travelTime.getMinutes().toString();
            
            localStorage.setItem('travelDate', dateStr);
            localStorage.setItem('travelHour', hour);
            localStorage.setItem('travelMinute', minute);
            
            // DISABLED: No longer force hardcoded surcharge settings
            // Respect whatever admin has configured in the admin panel
            console.log('‚ö° Test function disabled - respecting admin settings');
            
            console.log('‚úÖ Test data set:', { dateStr, hour, minute, settings });
            
            // Re-render vehicles
            renderVehicles();
            
            // Check if working
            checkLastMinuteBooking();
            
            console.log('üîç Check vehicle cards for crossed-out prices!');
        };
        // Update only vehicle prices without clearing the entire display
        function updateVehiclePricesOnly() {
            try {
                console.log('üîÑ Updating vehicle prices only (preserving photos and layout)...');
                
                // Find all vehicle cards
                const vehicleCards = document.querySelectorAll('.vehicle-card');
                
                vehicleCards.forEach(card => {
                    const vehicleId = card.dataset.vehicleId;
                    if (!vehicleId) return;
                    
                    // Find the vehicle data
                    const vehicle = vehicles.find(v => v.id === vehicleId);
                    if (!vehicle) return;
                    
                    // Calculate new price with current settings
                    const basePrice = calculateVehiclePrice(vehicle);
                    const lastMinuteSurcharge = calculateLastMinuteSurcharge(basePrice);
                    const totalPrice = Math.ceil(basePrice + lastMinuteSurcharge);
                    
                    // Update only the price display
                    const priceElement = card.querySelector('.vehicle-price .price-amount');
                    if (priceElement) {
                        priceElement.textContent = `‚Ç¨${totalPrice.toFixed(2)}`;
                        console.log(`‚úÖ Updated ${vehicle.name} price to ‚Ç¨${totalPrice.toFixed(2)}`);
                    }
                });
                
                console.log('‚úÖ Vehicle prices updated successfully without clearing photos');
                
            } catch (error) {
                console.error('‚ùå Error updating vehicle prices only:', error);
                // Fallback to full re-render if price-only update fails
                console.log('üîÑ Falling back to full vehicle re-render...');
                renderVehicles();
            }
        }
        
    </script>
</body>
</html>